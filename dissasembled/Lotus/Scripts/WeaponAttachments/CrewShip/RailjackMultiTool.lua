
main <?:0,0> (146 instructions, 584 bytes at 0000016098C734B0)
0+ params, 46 slots, 0 upvalues, 0 locals, 12 constants, 24 functions
	1	[1]	GETGLOBAL	R0 K0 ; R0 := 0x2d0fad09
	2	[1]	LOADK    	R1 K1 ; R1 := "Lotus.Scripts.Libs.PlayerSkillsLib"
	3	[1]	CALL     	R0 2 2 ; R0 := R0(R1)
	4	[2]	GETGLOBAL	R1 K0 ; R1 := 0x2d0fad09
	5	[2]	LOADK    	R2 K2 ; R2 := "Lotus.Scripts.Libs.RailjackUtilities"
	6	[2]	CALL     	R1 2 2 ; R1 := R1(R2)
	7	[22]	LOADNIL  	R2 R3 ; R2 := R3 := nil
	8	[24]	OP_LOADBOOL	R4 0 0 ; R4 := false
	9	[25]	LOADNIL  	R5 R7 ; R5 := R6 := R7 := nil
	10	[29]	LOADK    	R8 K3 ; R8 := 0.010000
	11	[30]	LOADK    	R9 K4 ; R9 := 0.040000
	12	[31]	LOADK    	R10 := 0.000000
	13	[33]	OP_LOADBOOL	R11 0 0 ; R11 := false
	14	[35]	OP_LOADBOOL	R12 0 0 ; R12 := false
	15	[36]	OP_LOADBOOL	R13 0 0 ; R13 := false
	16	[37]	OP_LOADBOOL	R14 0 0 ; R14 := false
	17	[38]	OP_LOADBOOL	R15 0 0 ; R15 := false
	18	[40]	LOADNIL  	R16 R18 ; R16 := R17 := R18 := nil
	19	[44]	GETGLOBAL	R19 K5 ; R19 := 0x0469f296
	20	[44]	LOADK    	R20 K6 ; R20 := "/Lotus/Language/Railjack/TacCallRepair"
	21	[44]	CALL     	R19 2 2 ; R19 := R19(R20)
	22	[47]	GETGLOBAL	R20 K5 ; R20 := 0x0469f296
	23	[47]	LOADK    	R21 K7 ; R21 := "EmissiveMapAtten"
	24	[47]	CALL     	R20 2 2 ; R20 := R20(R21)
	25	[48]	GETGLOBAL	R21 K5 ; R21 := 0x0469f296
	26	[48]	LOADK    	R22 K8 ; R22 := "EmissiveTintColor"
	27	[48]	CALL     	R21 2 2 ; R21 := R21(R22)
	28	[51]	LOADNIL  	R22 R23 ; R22 := R23 := nil
	29	[54]	LOADK    	R24 := 0.500000
	30	[55]	LOADK    	R25 := 1.000000
	31	[59]	CLOSURE  	R26 0 ; R26 := closure(Function #1)
	32	[85]	CLOSURE  	R27 1 ; R27 := closure(Function #2)
	33	[85]	MOVE     	R0 R3 ; R0 := R3
	34	[85]	MOVE     	R0 R5 ; R0 := R5
	35	[97]	CLOSURE  	R28 2 ; R28 := closure(Function #3)
	36	[108]	CLOSURE  	R29 3 ; R29 := closure(Function #4)
	37	[120]	CLOSURE  	R30 4 ; R30 := closure(Function #5)
	38	[124]	CLOSURE  	R31 5 ; R31 := closure(Function #6)
	39	[124]	MOVE     	R0 R30 ; R0 := R30
	40	[139]	CLOSURE  	R32 6 ; R32 := closure(Function #7)
	41	[139]	MOVE     	R0 R4 ; R0 := R4
	42	[162]	CLOSURE  	R33 7 ; R33 := closure(Function #8)
	43	[162]	MOVE     	R0 R32 ; R0 := R32
	44	[190]	CLOSURE  	R34 8 ; R34 := closure(Function #9)
	45	[190]	MOVE     	R0 R33 ; R0 := R33
	46	[190]	MOVE     	R0 R28 ; R0 := R28
	47	[212]	CLOSURE  	R35 9 ; R35 := closure(Function #10)
	48	[212]	MOVE     	R0 R26 ; R0 := R26
	49	[220]	CLOSURE  	R36 10 ; R36 := closure(Function #11)
	50	[227]	CLOSURE  	R37 11 ; R37 := closure(Function #12)
	51	[270]	CLOSURE  	R38 12 ; R38 := closure(Function #13)
	52	[270]	MOVE     	R0 R4 ; R0 := R4
	53	[270]	MOVE     	R0 R37 ; R0 := R37
	54	[270]	MOVE     	R0 R16 ; R0 := R16
	55	[277]	CLOSURE  	R39 13 ; R39 := closure(Function #14)
	56	[277]	MOVE     	R0 R36 ; R0 := R36
	57	[277]	MOVE     	R0 R38 ; R0 := R38
	58	[312]	CLOSURE  	R40 14 ; R40 := closure(Function #15)
	59	[312]	MOVE     	R0 R12 ; R0 := R12
	60	[312]	MOVE     	R0 R11 ; R0 := R11
	61	[312]	MOVE     	R0 R15 ; R0 := R15
	62	[312]	MOVE     	R0 R18 ; R0 := R18
	63	[312]	MOVE     	R0 R23 ; R0 := R23
	64	[312]	MOVE     	R0 R7 ; R0 := R7
	65	[312]	MOVE     	R0 R9 ; R0 := R9
	66	[312]	MOVE     	R0 R39 ; R0 := R39
	67	[312]	MOVE     	R0 R6 ; R0 := R6
	68	[312]	MOVE     	R0 R14 ; R0 := R14
	69	[312]	MOVE     	R0 R2 ; R0 := R2
	70	[312]	MOVE     	R0 R20 ; R0 := R20
	71	[312]	MOVE     	R0 R21 ; R0 := R21
	72	[366]	CLOSURE  	R41 15 ; R41 := closure(Function #16)
	73	[366]	MOVE     	R0 R24 ; R0 := R24
	74	[366]	MOVE     	R0 R4 ; R0 := R4
	75	[366]	MOVE     	R0 R25 ; R0 := R25
	76	[366]	MOVE     	R0 R11 ; R0 := R11
	77	[366]	MOVE     	R0 R12 ; R0 := R12
	78	[366]	MOVE     	R0 R15 ; R0 := R15
	79	[366]	MOVE     	R0 R13 ; R0 := R13
	80	[366]	MOVE     	R0 R30 ; R0 := R30
	81	[366]	MOVE     	R0 R26 ; R0 := R26
	82	[366]	MOVE     	R0 R22 ; R0 := R22
	83	[366]	MOVE     	R0 R32 ; R0 := R32
	84	[366]	MOVE     	R0 R31 ; R0 := R31
	85	[390]	CLOSURE  	R23 16 ; R23 := closure(Function #17)
	86	[390]	MOVE     	R0 R5 ; R0 := R5
	87	[390]	MOVE     	R0 R8 ; R0 := R8
	88	[390]	MOVE     	R0 R3 ; R0 := R3
	89	[390]	MOVE     	R0 R10 ; R0 := R10
	90	[404]	CLOSURE  	R42 17 ; R42 := closure(Function #18)
	91	[404]	MOVE     	R0 R5 ; R0 := R5
	92	[404]	MOVE     	R0 R3 ; R0 := R3
	93	[404]	MOVE     	R0 R23 ; R0 := R23
	94	[404]	MOVE     	R0 R10 ; R0 := R10
	95	[422]	CLOSURE  	R43 18 ; R43 := closure(Function #19)
	96	[422]	MOVE     	R0 R18 ; R0 := R18
	97	[422]	MOVE     	R0 R20 ; R0 := R20
	98	[422]	MOVE     	R0 R26 ; R0 := R26
	99	[422]	MOVE     	R0 R17 ; R0 := R17
	100	[422]	MOVE     	R0 R34 ; R0 := R34
	101	[422]	MOVE     	R0 R28 ; R0 := R28
	102	[422]	MOVE     	R0 R35 ; R0 := R35
	103	[422]	MOVE     	R0 R16 ; R0 := R16
	104	[447]	CLOSURE  	R22 19 ; R22 := closure(Function #20)
	105	[447]	MOVE     	R0 R26 ; R0 := R26
	106	[447]	MOVE     	R0 R17 ; R0 := R17
	107	[447]	MOVE     	R0 R43 ; R0 := R43
	108	[447]	MOVE     	R0 R1 ; R0 := R1
	109	[447]	MOVE     	R0 R3 ; R0 := R3
	110	[501]	CLOSURE  	R44 20 ; R44 := closure(Function #21)
	111	[501]	MOVE     	R0 R6 ; R0 := R6
	112	[501]	MOVE     	R0 R3 ; R0 := R3
	113	[501]	MOVE     	R0 R5 ; R0 := R5
	114	[501]	MOVE     	R0 R2 ; R0 := R2
	115	[501]	MOVE     	R0 R16 ; R0 := R16
	116	[501]	MOVE     	R0 R42 ; R0 := R42
	117	[501]	MOVE     	R0 R26 ; R0 := R26
	118	[501]	MOVE     	R0 R43 ; R0 := R43
	119	[501]	MOVE     	R0 R12 ; R0 := R12
	120	[501]	MOVE     	R0 R13 ; R0 := R13
	121	[501]	MOVE     	R0 R14 ; R0 := R14
	122	[501]	MOVE     	R0 R11 ; R0 := R11
	123	[501]	MOVE     	R0 R17 ; R0 := R17
	124	[501]	MOVE     	R0 R15 ; R0 := R15
	125	[501]	MOVE     	R0 R27 ; R0 := R27
	126	[501]	MOVE     	R0 R28 ; R0 := R28
	127	[501]	MOVE     	R0 R40 ; R0 := R40
	128	[501]	MOVE     	R0 R41 ; R0 := R41
	129	[501]	MOVE     	R0 R22 ; R0 := R22
	130	[520]	CLOSURE  	R45 21 ; R45 := closure(Function #22)
	131	[520]	MOVE     	R0 R26 ; R0 := R26
	132	[520]	MOVE     	R0 R29 ; R0 := R29
	133	[520]	MOVE     	R0 R2 ; R0 := R2
	134	[520]	MOVE     	R0 R3 ; R0 := R3
	135	[520]	MOVE     	R0 R4 ; R0 := R4
	136	[520]	MOVE     	R0 R0 ; R0 := R0
	137	[520]	MOVE     	R0 R5 ; R0 := R5
	138	[520]	MOVE     	R0 R10 ; R0 := R10
	139	[520]	MOVE     	R0 R44 ; R0 := R44
	140	[503]	SETGLOBAL	R45 K9 ; OnEquipped := R45
	141	[578]	CLOSURE  	R45 22 ; R45 := closure(Function #23)
	142	[578]	MOVE     	R0 R19 ; R0 := R19
	143	[526]	SETGLOBAL	R45 K10 ; ConsumeRepairMaterialsAndRewardXP := R45
	144	[581]	CLOSURE  	R45 23 ; R45 := closure(Function #24)
	145	[580]	SETGLOBAL	R45 K11 ; RepairToolAdditionalInventory := R45
	146	[581]	RETURN   	R0 1 ; return 


function #1 <?:57,59> (1 instruction, 4 bytes at 0000016098C73630)
1 param, 2 slots, 0 upvalues, 0 locals, 0 constants, 0 functions
	1	[59]	RETURN   	R0 1 ; return 

function #2 <?:65,85> (53 instructions, 212 bytes at 0000016098C73700)
0 params, 5 slots, 2 upvalues, 0 locals, 11 constants, 0 functions
	1	[66]	GETGLOBAL	R0 K0 ; R0 := 0x9ba7909f
	2	[66]	SELF     	R0 R0 K1 ; R1 := R0; R0 := R0[0xbf9494fc]
	3	[66]	LOADK    	R2 K2 ; R2 := "Client.InfiniteAmmo"
	4	[66]	CALL     	R0 3 2 ; R0 := R0(R1,R2)
	5	[66]	TEST     	R0 1 ; if R0 then PC := 51
	6	[66]	JMP      	51 ; PC := 51
	7	[67]	GETGLOBAL	R0 K3 ; R0 := 0x7b998233
	8	[67]	GETUPVAL 	R1 U0 ; R1 := U0
	9	[67]	CALL     	R0 2 2 ; R0 := R0(R1)
	10	[67]	TEST     	R0 1 ; if R0 then PC := 53
	11	[67]	JMP      	53 ; PC := 53
	12	[68]	GETUPVAL 	R0 U0 ; R0 := U0
	13	[68]	SELF     	R0 R0 K4 ; R1 := R0; R0 := R0[0xf2deaf69]
	14	[68]	GETGLOBAL	R2 K5 ; R2 := gLotusOperatorAvatarType
	15	[68]	CALL     	R0 3 2 ; R0 := R0(R1,R2)
	16	[68]	TEST     	R0 1 ; if R0 then PC := 29
	17	[68]	JMP      	29 ; PC := 29
	18	[69]	GETGLOBAL	R0 K3 ; R0 := 0x7b998233
	19	[69]	GETUPVAL 	R1 U1 ; R1 := U1
	20	[69]	CALL     	R0 2 2 ; R0 := R0(R1)
	21	[69]	TEST     	R0 1 ; if R0 then PC := 53
	22	[69]	JMP      	53 ; PC := 53
	23	[70]	GETUPVAL 	R0 U1 ; R0 := U1
	24	[70]	SELF     	R0 R0 K6 ; R1 := R0; R0 := R0[0x4e434800]
	25	[70]	GETGLOBAL	R2 K7 ; R2 := 0x186b715b
	26	[70]	TAILCALL 	R0 3 0 ; R0,... := R0(R1,R2)
	27	[70]	RETURN   	R0 0 ; return R0,... 
	28	[71]	JMP      	53 ; PC := 53
	29	[73]	GETUPVAL 	R0 U0 ; R0 := U0
	30	[73]	SELF     	R0 R0 K8 ; R1 := R0; R0 := R0[0x5b89142c]
	31	[73]	CALL     	R0 2 2 ; R0 := R0(R1)
	32	[74]	GETGLOBAL	R1 K3 ; R1 := 0x7b998233
	33	[74]	MOVE     	R2 R0 ; R2 := R0
	34	[74]	CALL     	R1 2 2 ; R1 := R1(R2)
	35	[74]	TEST     	R1 1 ; if R1 then PC := 53
	36	[74]	JMP      	53 ; PC := 53
	37	[75]	SELF     	R1 R0 K9 ; R2 := R0; R1 := R0[0xa534c3ac]
	38	[75]	CALL     	R1 2 2 ; R1 := R1(R2)
	39	[76]	GETGLOBAL	R2 K3 ; R2 := 0x7b998233
	40	[76]	MOVE     	R3 R1 ; R3 := R1
	41	[76]	CALL     	R2 2 2 ; R2 := R2(R3)
	42	[76]	TEST     	R2 1 ; if R2 then PC := 53
	43	[76]	JMP      	53 ; PC := 53
	44	[77]	SELF     	R2 R1 K10 ; R3 := R1; R2 := R1[0xde321e6f]
	45	[77]	CALL     	R2 2 2 ; R2 := R2(R3)
	46	[77]	SELF     	R2 R2 K6 ; R3 := R2; R2 := R2[0x4e434800]
	47	[77]	GETGLOBAL	R4 K7 ; R4 := 0x186b715b
	48	[77]	TAILCALL 	R2 3 0 ; R2,... := R2(R3,R4)
	49	[77]	RETURN   	R2 0 ; return R2,... 
	50	[81]	JMP      	53 ; PC := 53
	51	[83]	LOADK    	R2 := 999.000000
	52	[83]	RETURN   	R2 2 ; return R2 
	53	[85]	RETURN   	R0 1 ; return 

function #3 <?:89,97> (20 instructions, 80 bytes at 0000016098C73790)
1 param, 4 slots, 0 upvalues, 0 locals, 4 constants, 0 functions
	1	[90]	GETGLOBAL	R1 K0 ; R1 := 0x7b998233
	2	[90]	MOVE     	R2 R0 ; R2 := R0
	3	[90]	CALL     	R1 2 2 ; R1 := R1(R2)
	4	[90]	TEST     	R1 1 ; if R1 then PC := 18
	5	[90]	JMP      	18 ; PC := 18
	6	[91]	SELF     	R1 R0 K1 ; R2 := R0; R1 := R0[0xf2deaf69]
	7	[91]	GETGLOBAL	R3 K2 ; R3 := 0x392a88f7
	8	[91]	CALL     	R1 3 2 ; R1 := R1(R2,R3)
	9	[91]	TEST     	R1 1 ; if R1 then PC := 16
	10	[91]	JMP      	16 ; PC := 16
	11	[91]	SELF     	R1 R0 K1 ; R2 := R0; R1 := R0[0xf2deaf69]
	12	[91]	GETGLOBAL	R3 K3 ; R3 := 0xa5dc8da5
	13	[91]	CALL     	R1 3 2 ; R1 := R1(R2,R3)
	14	[91]	TEST     	R1 0 ; if not R1 then PC := 18
	15	[91]	JMP      	18 ; PC := 18
	16	[92]	OP_LOADBOOL	R1 1 0 ; R1 := true
	17	[92]	RETURN   	R1 2 ; return R1 
	18	[96]	OP_LOADBOOL	R1 0 0 ; R1 := false
	19	[96]	RETURN   	R1 2 ; return R1 
	20	[97]	RETURN   	R0 1 ; return 

function #4 <?:99,108> (24 instructions, 96 bytes at 0000016098C73930)
0 params, 2 slots, 0 upvalues, 0 locals, 6 constants, 0 functions
	1	[100]	GETGLOBAL	R0 K0 ; R0 := 0x7b998233
	2	[100]	GETGLOBAL	R1 K1 ; R1 := _T
	3	[100]	GETTABLE 	R1 R1 K2 ; R1 := R1["MultiTool"]
	4	[100]	CALL     	R0 2 2 ; R0 := R0(R1)
	5	[100]	TEST     	R0 0 ; if not R0 then PC := 10
	6	[100]	JMP      	10 ; PC := 10
	7	[101]	GETGLOBAL	R0 K1 ; R0 := _T
	8	[101]	NEWTABLE 	R1 0 0 ; R1 := {}
	9	[101]	SETTABLE 	R0 K2 R1 ; R0["MultiTool"] := R1
	10	[104]	GETGLOBAL	R0 K0 ; R0 := 0x7b998233
	11	[104]	GETGLOBAL	R1 K1 ; R1 := _T
	12	[104]	GETTABLE 	R1 R1 K2 ; R1 := R1["MultiTool"]
	13	[104]	GETTABLE 	R1 R1 K3 ; R1 := R1["ActiveRepairsInfo"]
	14	[104]	CALL     	R0 2 2 ; R0 := R0(R1)
	15	[104]	TEST     	R0 0 ; if not R0 then PC := 24
	16	[104]	JMP      	24 ; PC := 24
	17	[105]	GETGLOBAL	R0 K1 ; R0 := _T
	18	[105]	GETTABLE 	R0 R0 K2 ; R0 := R0["MultiTool"]
	19	[105]	NEWTABLE 	R1 0 0 ; R1 := {}
	20	[105]	SETTABLE 	R0 K3 R1 ; R0["ActiveRepairsInfo"] := R1
	21	[106]	GETGLOBAL	R0 K1 ; R0 := _T
	22	[106]	GETTABLE 	R0 R0 K2 ; R0 := R0["MultiTool"]
	23	[106]	SETTABLE 	R0 K4 K5 ; R0["ActiveRepairsCount"] := 0.000000
	24	[108]	RETURN   	R0 1 ; return 

function #5 <?:110,120> (26 instructions, 104 bytes at 0000016098C73AA0)
2 params, 6 slots, 0 upvalues, 0 locals, 6 constants, 0 functions
	1	[113]	LOADK    	R2 K0 ; R2 := 0.015000
	2	[114]	GETGLOBAL	R3 K1 ; R3 := 0x5bced4c4
	3	[114]	GETTABLE 	R3 R3 K2 ; R3 := R3[0xac1b386a]
	4	[114]	ADD      	R4 R1 R2 ; R4 := R1 + R2
	5	[114]	LOADK    	R5 := 1.000000
	6	[114]	CALL     	R3 3 2 ; R3 := R3(R4,R5)
	7	[116]	GETTABLE 	R4 R0 K3 ; R4 := R0["START"]
	8	[116]	LT       	1 K4 R4 ; if 0.000000 < R4 then PC := 13
	9	[116]	JMP      	13 ; PC := 13
	10	[116]	GETTABLE 	R4 R0 K5 ; R4 := R0["END"]
	11	[116]	LT       	0 K4 R4 ; if 0.000000 >= R4 then PC := 23
	12	[116]	JMP      	23 ; PC := 23
	13	[117]	GETTABLE 	R4 R0 K5 ; R4 := R0["END"]
	14	[117]	GETTABLE 	R5 R0 K3 ; R5 := R0["START"]
	15	[117]	LT       	0 R5 R4 ; if R5 >= R4 then PC := 23
	16	[117]	JMP      	23 ; PC := 23
	17	[118]	GETTABLE 	R4 R0 K3 ; R4 := R0["START"]
	18	[118]	LE       	0 R4 R3 ; if R4 > R3 then PC := 23
	19	[118]	JMP      	23 ; PC := 23
	20	[119]	GETTABLE 	R4 R0 K5 ; R4 := R0["END"]
	21	[119]	LE       	1 R3 R4 ; if R3 <= R4 then PC := 24
	22	[119]	JMP      	24 ; PC := 24
	23	[119]	OP_LOADBOOL	R4 0 1 ; R4 := false; PC := 24
	24	[119]	OP_LOADBOOL	R4 1 0 ; R4 := true
	25	[119]	RETURN   	R4 2 ; return R4 
	26	[120]	RETURN   	R0 1 ; return 

function #6 <?:122,124> (15 instructions, 60 bytes at 0000016098C73C00)
3 params, 6 slots, 1 upvalue, 0 locals, 0 constants, 0 functions
	1	[123]	GETUPVAL 	R3 U0 ; R3 := U0
	2	[123]	MOVE     	R4 R0 ; R4 := R0
	3	[123]	MOVE     	R5 R1 ; R5 := R1
	4	[123]	CALL     	R3 3 2 ; R3 := R3(R4,R5)
	5	[123]	TEST     	R3 1 ; if R3 then PC := 12
	6	[123]	JMP      	12 ; PC := 12
	7	[123]	GETUPVAL 	R3 U0 ; R3 := U0
	8	[123]	MOVE     	R4 R0 ; R4 := R0
	9	[123]	MOVE     	R5 R2 ; R5 := R2
	10	[123]	CALL     	R3 3 2 ; R3 := R3(R4,R5)
	11	[123]	JMP      	14 ; PC := 14
	12	[123]	OP_LOADBOOL	R3 0 1 ; R3 := false; PC := 13
	13	[123]	OP_LOADBOOL	R3 1 0 ; R3 := true
	14	[123]	RETURN   	R3 2 ; return R3 
	15	[124]	RETURN   	R0 1 ; return 

function #7 <?:126,139> (25 instructions, 100 bytes at 0000016098C73D30)
0 params, 8 slots, 1 upvalue, 0 locals, 5 constants, 0 functions
	1	[127]	GETUPVAL 	R0 U0 ; R0 := U0
	2	[127]	TEST     	R0 0 ; if not R0 then PC := 22
	3	[127]	JMP      	22 ; PC := 22
	4	[128]	LOADK    	R0 K0 ; R0 := 0.300000
	5	[129]	LOADK    	R1 K1 ; R1 := 0.030000
	6	[130]	LOADK    	R2 K2 ; R2 := 0.050000
	7	[132]	SUB      	R3 K3 R0 ; R3 := 1.000000 - R0
	8	[132]	ADD      	R4 R1 R2 ; R4 := R1 + R2
	9	[132]	SUB      	R3 R3 R4 ; R3 := R3 - R4
	10	[133]	GETGLOBAL	R4 K4 ; R4 := 0xc163f229
	11	[133]	LOADK    	R5 := 0.000000
	12	[133]	MOVE     	R6 R3 ; R6 := R3
	13	[133]	CALL     	R4 3 2 ; R4 := R4(R5,R6)
	14	[133]	ADD      	R4 R0 R4 ; R4 := R0 + R4
	15	[134]	GETGLOBAL	R5 K4 ; R5 := 0xc163f229
	16	[134]	MOVE     	R6 R1 ; R6 := R1
	17	[134]	ADD      	R7 R1 R2 ; R7 := R1 + R2
	18	[134]	CALL     	R5 3 2 ; R5 := R5(R6,R7)
	19	[136]	MOVE     	R6 R4 ; R6 := R4
	20	[136]	ADD      	R7 R4 R5 ; R7 := R4 + R5
	21	[136]	RETURN   	R6 3 ; return R6, R7 
	22	[138]	LOADK    	R6 := 0.000000
	23	[138]	LOADK    	R7 := 0.000000
	24	[138]	RETURN   	R6 3 ; return R6, R7 
	25	[139]	RETURN   	R0 1 ; return 

function #8 <?:142,162> (29 instructions, 116 bytes at 0000016098C73E20)
2 params, 6 slots, 1 upvalue, 0 locals, 14 constants, 0 functions
	1	[143]	NEWTABLE 	R2 0 0 ; R2 := {}
	2	[144]	SETTABLE 	R2 K0 R0 ; R2["target"] := R0
	3	[145]	SETTABLE 	R2 K1 K2 ; R2["lastUpdateTime"] := nil
	4	[147]	SETTABLE 	R2 K3 K4 ; R2["progression"] := 0.000000
	5	[148]	SETTABLE 	R2 K5 K6 ; R2["progressionDirection"] := 1.000000
	6	[150]	NEWTABLE 	R3 0 2 ; R3 := {}
	7	[150]	SETTABLE 	R3 K8 K4 ; R3["START"] := 0.000000
	8	[150]	SETTABLE 	R3 K9 K4 ; R3["END"] := 0.000000
	9	[150]	SETTABLE 	R2 K7 R3 ; R2["baseSweetSpot"] := R3
	10	[151]	NEWTABLE 	R3 0 2 ; R3 := {}
	11	[151]	SETTABLE 	R3 K8 K4 ; R3["START"] := 0.000000
	12	[151]	SETTABLE 	R3 K9 K4 ; R3["END"] := 0.000000
	13	[151]	SETTABLE 	R2 K10 R3 ; R2["sweetSpot"] := R3
	14	[152]	SETTABLE 	R2 K11 K12 ; R2["enteredSweetSpot"] := false
	15	[154]	TEST     	R1 0 ; if not R1 then PC := 27
	16	[154]	JMP      	27 ; PC := 27
	17	[155]	GETUPVAL 	R3 U0 ; R3 := U0
	18	[155]	CALL     	R3 1 3 ; R3,R4 := R3()
	19	[156]	NEWTABLE 	R5 0 2 ; R5 := {}
	20	[156]	SETTABLE 	R5 K8 R3 ; R5["START"] := R3
	21	[156]	SETTABLE 	R5 K9 R4 ; R5["END"] := R4
	22	[156]	SETTABLE 	R2 K7 R5 ; R2["baseSweetSpot"] := R5
	23	[157]	NEWTABLE 	R5 0 2 ; R5 := {}
	24	[157]	SETTABLE 	R5 K8 R3 ; R5["START"] := R3
	25	[157]	SETTABLE 	R5 K9 R4 ; R5["END"] := R4
	26	[157]	SETTABLE 	R2 K10 R5 ; R2["sweetSpot"] := R5
	27	[159]	SETTABLE 	R2 K13 K4 ; R2["gemSpot"] := 0.000000
	28	[161]	RETURN   	R2 2 ; return R2 
	29	[162]	RETURN   	R0 1 ; return 

function #9 <?:164,190> (78 instructions, 312 bytes at 0000016098C74030)
1 param, 10 slots, 2 upvalues, 0 locals, 11 constants, 0 functions
	1	[165]	GETGLOBAL	R1 K0 ; R1 := 0x7b998233
	2	[165]	MOVE     	R2 R0 ; R2 := R0
	3	[165]	CALL     	R1 2 2 ; R1 := R1(R2)
	4	[165]	TEST     	R1 1 ; if R1 then PC := 78
	5	[165]	JMP      	78 ; PC := 78
	6	[166]	LOADK    	R1 := -1.000000
	7	[167]	LOADK    	R2 := 1.000000
	8	[167]	GETGLOBAL	R3 K1 ; R3 := _T
	9	[167]	GETTABLE 	R3 R3 K2 ; R3 := R3["MultiTool"]
	10	[167]	GETTABLE 	R3 R3 K3 ; R3 := R3["ActiveRepairsCount"]
	11	[167]	LOADK    	R4 := 1.000000
	12	[167]	FORPREP  	R2 48 ; R2 -= R4; PC := 48
	13	[168]	GETGLOBAL	R6 K0 ; R6 := 0x7b998233
	14	[168]	GETGLOBAL	R7 K1 ; R7 := _T
	15	[168]	GETTABLE 	R7 R7 K2 ; R7 := R7["MultiTool"]
	16	[168]	GETTABLE 	R7 R7 K4 ; R7 := R7["ActiveRepairsInfo"]
	17	[168]	GETTABLE 	R7 R7 R5 ; R7 := R7[R5]
	18	[168]	CALL     	R6 2 2 ; R6 := R6(R7)
	19	[168]	TEST     	R6 1 ; if R6 then PC := 30
	20	[168]	JMP      	30 ; PC := 30
	21	[168]	GETGLOBAL	R6 K0 ; R6 := 0x7b998233
	22	[168]	GETGLOBAL	R7 K1 ; R7 := _T
	23	[168]	GETTABLE 	R7 R7 K2 ; R7 := R7["MultiTool"]
	24	[168]	GETTABLE 	R7 R7 K4 ; R7 := R7["ActiveRepairsInfo"]
	25	[168]	GETTABLE 	R7 R7 R5 ; R7 := R7[R5]
	26	[168]	GETTABLE 	R7 R7 K5 ; R7 := R7["target"]
	27	[168]	CALL     	R6 2 2 ; R6 := R6(R7)
	28	[168]	TEST     	R6 0 ; if not R6 then PC := 36
	29	[168]	JMP      	36 ; PC := 36
	30	[169]	MOVE     	R1 R5 ; R1 := R5
	31	[170]	GETGLOBAL	R6 K1 ; R6 := _T
	32	[170]	GETTABLE 	R6 R6 K2 ; R6 := R6["MultiTool"]
	33	[170]	GETTABLE 	R6 R6 K4 ; R6 := R6["ActiveRepairsInfo"]
	34	[170]	SETTABLE 	R6 R1 K6 ; R6[R1] := nil
	35	[170]	JMP      	48 ; PC := 48
	36	[171]	GETGLOBAL	R6 K1 ; R6 := _T
	37	[171]	GETTABLE 	R6 R6 K2 ; R6 := R6["MultiTool"]
	38	[171]	GETTABLE 	R6 R6 K4 ; R6 := R6["ActiveRepairsInfo"]
	39	[171]	GETTABLE 	R6 R6 R5 ; R6 := R6[R5]
	40	[171]	GETTABLE 	R6 R6 K5 ; R6 := R6["target"]
	41	[171]	EQ       	0 R0 R6 ; if R0 ~= R6 then PC := 48
	42	[171]	JMP      	48 ; PC := 48
	43	[173]	GETGLOBAL	R6 K1 ; R6 := _T
	44	[173]	GETTABLE 	R6 R6 K2 ; R6 := R6["MultiTool"]
	45	[173]	GETTABLE 	R6 R6 K4 ; R6 := R6["ActiveRepairsInfo"]
	46	[173]	GETTABLE 	R6 R6 R5 ; R6 := R6[R5]
	47	[173]	RETURN   	R6 2 ; return R6 
	48	[167]	FORLOOP  	R2 13 ; R2 += R4; if R2 <= R3 then begin PC := 13; R5 := R2 end
	49	[177]	GETUPVAL 	R6 U0 ; R6 := U0
	50	[177]	MOVE     	R7 R0 ; R7 := R0
	51	[177]	GETUPVAL 	R8 U1 ; R8 := U1
	52	[177]	MOVE     	R9 R0 ; R9 := R0
	53	[177]	CALL     	R8 2 2 ; R8 := R8(R9)
	54	[177]	NOT      	R8 R8 ; R8 := not R8
	55	[177]	CALL     	R6 3 2 ; R6 := R6(R7,R8)
	56	[178]	LT       	0 R1 K7 ; if R1 >= 0.000000 then PC := 73
	57	[178]	JMP      	73 ; PC := 73
	58	[179]	GETGLOBAL	R7 K8 ; R7 := 0x33bdd652
	59	[179]	GETTABLE 	R7 R7 K9 ; R7 := R7[0x23d5322f]
	60	[179]	GETGLOBAL	R8 K1 ; R8 := _T
	61	[179]	GETTABLE 	R8 R8 K2 ; R8 := R8["MultiTool"]
	62	[179]	GETTABLE 	R8 R8 K4 ; R8 := R8["ActiveRepairsInfo"]
	63	[179]	MOVE     	R9 R6 ; R9 := R6
	64	[179]	CALL     	R7 3 1 ; R7(R8,R9)
	65	[180]	GETGLOBAL	R7 K1 ; R7 := _T
	66	[180]	GETTABLE 	R7 R7 K2 ; R7 := R7["MultiTool"]
	67	[180]	GETGLOBAL	R8 K1 ; R8 := _T
	68	[180]	GETTABLE 	R8 R8 K2 ; R8 := R8["MultiTool"]
	69	[180]	GETTABLE 	R8 R8 K3 ; R8 := R8["ActiveRepairsCount"]
	70	[180]	ADD      	R8 R8 K10 ; R8 := R8 + 1.000000
	71	[180]	SETTABLE 	R7 K3 R8 ; R7["ActiveRepairsCount"] := R8
	72	[180]	JMP      	77 ; PC := 77
	73	[185]	GETGLOBAL	R7 K1 ; R7 := _T
	74	[185]	GETTABLE 	R7 R7 K2 ; R7 := R7["MultiTool"]
	75	[185]	GETTABLE 	R7 R7 K4 ; R7 := R7["ActiveRepairsInfo"]
	76	[185]	SETTABLE 	R7 R1 R6 ; R7[R1] := R6
	77	[188]	RETURN   	R6 2 ; return R6 
	78	[190]	RETURN   	R0 1 ; return 

function #10 <?:195,212> (57 instructions, 228 bytes at 0000016098C740C0)
1 param, 15 slots, 1 upvalue, 0 locals, 16 constants, 0 functions
	1	[196]	GETUPVAL 	R1 U0 ; R1 := U0
	2	[196]	LOADK    	R2 K0 ; R2 := "FetchTargetBreachInfo"
	3	[196]	CALL     	R1 2 1 ; R1(R2)
	4	[198]	GETGLOBAL	R1 K1 ; R1 := 0x7b998233
	5	[198]	GETGLOBAL	R2 K2 ; R2 := _T
	6	[198]	GETTABLE 	R2 R2 K3 ; R2 := R2["WallBreaches"]
	7	[198]	CALL     	R1 2 2 ; R1 := R1(R2)
	8	[198]	TEST     	R1 1 ; if R1 then PC := 51
	9	[198]	JMP      	51 ; PC := 51
	10	[199]	GETUPVAL 	R1 U0 ; R1 := U0
	11	[199]	LOADK    	R2 K4 ; R2 := "not IsNull(_T.WallBreaches)"
	12	[199]	CALL     	R1 2 1 ; R1(R2)
	13	[200]	GETGLOBAL	R1 K5 ; R1 := 0xcfc01047
	14	[200]	GETGLOBAL	R2 K2 ; R2 := _T
	15	[200]	GETTABLE 	R2 R2 K3 ; R2 := R2["WallBreaches"]
	16	[200]	CALL     	R1 2 4 ; R1,R2,R3 := R1(R2)
	17	[200]	JMP      	48 ; PC := 48
	18	[201]	GETGLOBAL	R6 K1 ; R6 := 0x7b998233
	19	[201]	MOVE     	R7 R4 ; R7 := R4
	20	[201]	CALL     	R6 2 2 ; R6 := R6(R7)
	21	[201]	TEST     	R6 1 ; if R6 then PC := 48
	22	[201]	JMP      	48 ; PC := 48
	23	[201]	EQ       	0 R4 R0 ; if R4 ~= R0 then PC := 48
	24	[201]	JMP      	48 ; PC := 48
	25	[202]	GETUPVAL 	R6 U0 ; R6 := U0
	26	[202]	LOADK    	R7 K6 ; R7 := "Found breach info for "
	27	[202]	SELF     	R8 R0 K7 ; R9 := R0; R8 := R0[0xed4e0128]
	28	[202]	CALL     	R8 2 2 ; R8 := R8(R9)
	29	[202]	CONCAT   	R7 R7 R8 ; R7 := R7 .. R8
	30	[202]	CALL     	R6 2 1 ; R6(R7)
	31	[203]	GETGLOBAL	R6 K8 ; R6 := 0x9808fb37
	32	[203]	TEST     	R6 0 ; if not R6 then PC := 47
	33	[203]	JMP      	47 ; PC := 47
	34	[204]	GETGLOBAL	R6 K9 ; R6 := 0x89326c93
	35	[204]	SELF     	R6 R6 K10 ; R7 := R6; R6 := R6[0x9ed3b54e]
	36	[204]	SELF     	R8 R0 K11 ; R9 := R0; R8 := R0[0xd1586535]
	37	[204]	CALL     	R8 2 2 ; R8 := R8(R9)
	38	[204]	LOADK    	R9 K12 ; R9 := 0.400000
	39	[204]	GETGLOBAL	R10 K13 ; R10 := 0x60130201
	40	[204]	LOADK    	R11 := 0.000000
	41	[204]	LOADK    	R12 := 100.000000
	42	[204]	LOADK    	R13 := 100.000000
	43	[204]	LOADK    	R14 := 255.000000
	44	[204]	CALL     	R10 5 2 ; R10 := R10(R11,R12,R13,R14)
	45	[204]	LOADK    	R11 := 2.000000
	46	[204]	CALL     	R6 6 1 ; R6(R7,R8,R9,R10,R11)
	47	[206]	RETURN   	R5 2 ; return R5 
	48	[200]	TFORLOOP 	R1 2 ; R4,R5 := R1(R2,R3); if R4 ~= nil then begin PC = 18; R3 := R4 end
	49	[207]	JMP      	18 ; PC := 18
	50	[208]	JMP      	57 ; PC := 57
	51	[210]	GETGLOBAL	R6 K14 ; R6 := 0x3d106989
	52	[210]	LOADK    	R7 K15 ; R7 := "ERROR: _T.WallBreaches not found. Information not created for "
	53	[210]	SELF     	R8 R0 K7 ; R9 := R0; R8 := R0[0xed4e0128]
	54	[210]	CALL     	R8 2 2 ; R8 := R8(R9)
	55	[210]	CONCAT   	R7 R7 R8 ; R7 := R7 .. R8
	56	[210]	CALL     	R6 2 1 ; R6(R7)
	57	[212]	RETURN   	R0 1 ; return 

function #11 <?:214,220> (28 instructions, 112 bytes at 0000016098C74210)
3 params, 5 slots, 0 upvalues, 0 locals, 3 constants, 0 functions
	1	[216]	GETTABLE 	R3 R1 K0 ; R3 := R1["x"]
	2	[216]	GETTABLE 	R4 R0 K0 ; R4 := R0["x"]
	3	[216]	LE       	0 R3 R4 ; if R3 > R4 then PC := 25
	4	[216]	JMP      	25 ; PC := 25
	5	[216]	GETTABLE 	R3 R0 K0 ; R3 := R0["x"]
	6	[216]	GETTABLE 	R4 R2 K0 ; R4 := R2["x"]
	7	[216]	LE       	0 R3 R4 ; if R3 > R4 then PC := 25
	8	[216]	JMP      	25 ; PC := 25
	9	[217]	GETTABLE 	R3 R1 K1 ; R3 := R1["y"]
	10	[217]	GETTABLE 	R4 R0 K1 ; R4 := R0["y"]
	11	[217]	LE       	0 R3 R4 ; if R3 > R4 then PC := 25
	12	[217]	JMP      	25 ; PC := 25
	13	[217]	GETTABLE 	R3 R0 K1 ; R3 := R0["y"]
	14	[217]	GETTABLE 	R4 R2 K1 ; R4 := R2["y"]
	15	[217]	LE       	0 R3 R4 ; if R3 > R4 then PC := 25
	16	[217]	JMP      	25 ; PC := 25
	17	[218]	GETTABLE 	R3 R1 K2 ; R3 := R1["z"]
	18	[218]	GETTABLE 	R4 R0 K2 ; R4 := R0["z"]
	19	[218]	LE       	0 R3 R4 ; if R3 > R4 then PC := 25
	20	[218]	JMP      	25 ; PC := 25
	21	[218]	GETTABLE 	R3 R0 K2 ; R3 := R0["z"]
	22	[218]	GETTABLE 	R4 R2 K2 ; R4 := R2["z"]
	23	[218]	LE       	1 R3 R4 ; if R3 <= R4 then PC := 26
	24	[218]	JMP      	26 ; PC := 26
	25	[219]	OP_LOADBOOL	R3 0 1 ; R3 := false; PC := 26
	26	[219]	OP_LOADBOOL	R3 1 0 ; R3 := true
	27	[219]	RETURN   	R3 2 ; return R3 
	28	[220]	RETURN   	R0 1 ; return 

function #12 <?:222,227> (16 instructions, 64 bytes at 0000016098C742A0)
1 param, 7 slots, 0 upvalues, 0 locals, 4 constants, 0 functions
	1	[223]	LOADK    	R1 := 5.000000
	2	[224]	LOADK    	R2 := 3.000000
	3	[225]	GETGLOBAL	R3 K0 ; R3 := 0x42dcc9f5
	4	[225]	GETGLOBAL	R4 K1 ; R4 := 0x5bced4c4
	5	[225]	GETTABLE 	R4 R4 K2 ; R4 := R4[0xb62ecfe0]
	6	[225]	SUB      	R5 R0 K3 ; R5 := R0 - 1.000000
	7	[225]	LOADK    	R6 := 0.000000
	8	[225]	CALL     	R4 3 2 ; R4 := R4(R5,R6)
	9	[225]	DIV      	R4 R4 R1 ; R4 := R4 / R1
	10	[225]	LOADK    	R5 := 0.000000
	11	[225]	LOADK    	R6 := 1.000000
	12	[225]	CALL     	R3 4 2 ; R3 := R3(R4,R5,R6)
	13	[226]	SUB      	R4 K3 R3 ; R4 := 1.000000 - R3
	14	[226]	MUL      	R4 R2 R4 ; R4 := R2 * R4
	15	[226]	RETURN   	R4 2 ; return R4 
	16	[227]	RETURN   	R0 1 ; return 

function #13 <?:229,270> (144 instructions, 576 bytes at 0000016098C74420)
3 params, 29 slots, 3 upvalues, 0 locals, 25 constants, 0 functions
	1	[231]	GETTABLE 	R3 R0 K0 ; R3 := R0["points"]
	2	[233]	GETGLOBAL	R4 K1 ; R4 := 0xf03431cc
	3	[234]	GETUPVAL 	R5 U0 ; R5 := U0
	4	[234]	TEST     	R5 0 ; if not R5 then PC := 7
	5	[234]	JMP      	7 ; PC := 7
	6	[235]	GETGLOBAL	R4 K2 ; R4 := 0x13aa510d
	7	[237]	GETUPVAL 	R5 U1 ; R5 := U1
	8	[237]	LEN      	R6 R3 ; R6 := # R3
	9	[237]	CALL     	R5 2 2 ; R5 := R5(R6)
	10	[238]	MUL      	R6 R4 R5 ; R6 := R4 * R5
	11	[238]	ADD      	R6 R4 R6 ; R6 := R4 + R6
	12	[239]	GETGLOBAL	R7 K3 ; R7 := 0xc8802016
	13	[239]	MOVE     	R8 R3 ; R8 := R3
	14	[239]	CALL     	R7 2 4 ; R7,R8,R9 := R7(R8)
	15	[239]	JMP      	109 ; PC := 109
	16	[240]	GETGLOBAL	R12 K4 ; R12 := 0x9808fb37
	17	[240]	TEST     	R12 0 ; if not R12 then PC := 31
	18	[240]	JMP      	31 ; PC := 31
	19	[241]	GETGLOBAL	R12 K5 ; R12 := 0x89326c93
	20	[241]	SELF     	R12 R12 K6 ; R13 := R12; R12 := R12[0x9ed3b54e]
	21	[241]	MOVE     	R14 R11 ; R14 := R11
	22	[241]	MOVE     	R15 R6 ; R15 := R6
	23	[241]	GETGLOBAL	R16 K7 ; R16 := 0x60130201
	24	[241]	LOADK    	R17 := 200.000000
	25	[241]	LOADK    	R18 := 0.000000
	26	[241]	LOADK    	R19 := 50.000000
	27	[241]	LOADK    	R20 := 255.000000
	28	[241]	CALL     	R16 5 2 ; R16 := R16(R17,R18,R19,R20)
	29	[241]	GETGLOBAL	R17 K8 ; R17 := 0xf062bfa1
	30	[241]	CALL     	R12 6 1 ; R12(R13,R14,R15,R16,R17)
	31	[243]	GETGLOBAL	R12 K9 ; R12 := 0xb6489516
	32	[243]	MOVE     	R13 R1 ; R13 := R1
	33	[243]	ADD      	R14 R1 R2 ; R14 := R1 + R2
	34	[243]	MOVE     	R15 R11 ; R15 := R11
	35	[243]	CALL     	R12 4 2 ; R12 := R12(R13,R14,R15)
	36	[244]	LE       	0 R12 R6 ; if R12 > R6 then PC := 109
	37	[244]	JMP      	109 ; PC := 109
	38	[246]	GETGLOBAL	R13 K10 ; R13 := 0x33bdd652
	39	[246]	GETTABLE 	R13 R13 K11 ; R13 := R13[0x9c1f3b5a]
	40	[246]	GETTABLE 	R14 R0 K0 ; R14 := R0["points"]
	41	[246]	MOVE     	R15 R10 ; R15 := R10
	42	[246]	CALL     	R13 3 1 ; R13(R14,R15)
	43	[247]	GETTABLE 	R13 R0 K12 ; R13 := R0["pointDecos"]
	44	[247]	LEN      	R13 R13 ; R13 := # R13
	45	[247]	LT       	0 K13 R13 ; if 0.000000 >= R13 then PC := 65
	46	[247]	JMP      	65 ; PC := 65
	47	[247]	GETTABLE 	R13 R0 K12 ; R13 := R0["pointDecos"]
	48	[247]	LEN      	R13 R13 ; R13 := # R13
	49	[247]	LE       	0 R10 R13 ; if R10 > R13 then PC := 65
	50	[247]	JMP      	65 ; PC := 65
	51	[248]	GETTABLE 	R13 R0 K12 ; R13 := R0["pointDecos"]
	52	[248]	GETTABLE 	R13 R13 R10 ; R13 := R13[R10]
	53	[249]	GETGLOBAL	R14 K10 ; R14 := 0x33bdd652
	54	[249]	GETTABLE 	R14 R14 K11 ; R14 := R14[0x9c1f3b5a]
	55	[249]	GETTABLE 	R15 R0 K12 ; R15 := R0["pointDecos"]
	56	[249]	MOVE     	R16 R10 ; R16 := R10
	57	[249]	CALL     	R14 3 1 ; R14(R15,R16)
	58	[250]	GETGLOBAL	R14 K14 ; R14 := 0x7b998233
	59	[250]	MOVE     	R15 R13 ; R15 := R13
	60	[250]	CALL     	R14 2 2 ; R14 := R14(R15)
	61	[250]	TEST     	R14 1 ; if R14 then PC := 65
	62	[250]	JMP      	65 ; PC := 65
	63	[251]	SELF     	R14 R13 K15 ; R15 := R13; R14 := R13[0xa2880940]
	64	[251]	CALL     	R14 2 1 ; R14(R15)
	65	[254]	GETGLOBAL	R14 K10 ; R14 := 0x33bdd652
	66	[254]	GETTABLE 	R14 R14 K16 ; R14 := R14[0x23d5322f]
	67	[254]	GETTABLE 	R15 R0 K17 ; R15 := R0["repairedPoints"]
	68	[254]	MOVE     	R16 R11 ; R16 := R11
	69	[254]	CALL     	R14 3 1 ; R14(R15,R16)
	70	[255]	GETGLOBAL	R14 K14 ; R14 := 0x7b998233
	71	[255]	GETTABLE 	R15 R0 K18 ; R15 := R0["repairedPointDecoType"]
	72	[255]	CALL     	R14 2 2 ; R14 := R14(R15)
	73	[255]	TEST     	R14 1 ; if R14 then PC := 109
	74	[255]	JMP      	109 ; PC := 109
	75	[256]	GETGLOBAL	R14 K5 ; R14 := 0x89326c93
	76	[256]	SELF     	R14 R14 K19 ; R15 := R14; R14 := R14[0x05909209]
	77	[256]	GETTABLE 	R16 R0 K18 ; R16 := R0["repairedPointDecoType"]
	78	[256]	MOVE     	R17 R11 ; R17 := R11
	79	[256]	GETGLOBAL	R18 K20 ; R18 := 0x00046924
	80	[256]	GETGLOBAL	R19 K21 ; R19 := 0x5bced4c4
	81	[256]	GETTABLE 	R19 R19 K22 ; R19 := R19[0x3630e649]
	82	[256]	LOADK    	R20 := -180.000000
	83	[256]	LOADK    	R21 := 180.000000
	84	[256]	CALL     	R19 3 2 ; R19 := R19(R20,R21)
	85	[256]	GETGLOBAL	R20 K21 ; R20 := 0x5bced4c4
	86	[256]	GETTABLE 	R20 R20 K22 ; R20 := R20[0x3630e649]
	87	[256]	LOADK    	R21 := -180.000000
	88	[256]	LOADK    	R22 := 180.000000
	89	[256]	CALL     	R20 3 2 ; R20 := R20(R21,R22)
	90	[256]	GETGLOBAL	R21 K21 ; R21 := 0x5bced4c4
	91	[256]	GETTABLE 	R21 R21 K22 ; R21 := R21[0x3630e649]
	92	[256]	LOADK    	R22 := -180.000000
	93	[256]	LOADK    	R23 := 180.000000
	94	[256]	CALL     	R21 3 0 ; R21,... := R21(R22,R23)
	95	[256]	CALL     	R18 0 2 ; R18 := R18(R19,...)
	96	[256]	GETUPVAL 	R19 U2 ; R19 := U2
	97	[256]	GETUPVAL 	R20 U2 ; R20 := U2
	98	[256]	CALL     	R14 7 2 ; R14 := R14(R15,R16,R17,R18,R19,R20)
	99	[257]	GETGLOBAL	R15 K14 ; R15 := 0x7b998233
	100	[257]	MOVE     	R16 R14 ; R16 := R14
	101	[257]	CALL     	R15 2 2 ; R15 := R15(R16)
	102	[257]	TEST     	R15 1 ; if R15 then PC := 109
	103	[257]	JMP      	109 ; PC := 109
	104	[258]	GETGLOBAL	R15 K10 ; R15 := 0x33bdd652
	105	[258]	GETTABLE 	R15 R15 K16 ; R15 := R15[0x23d5322f]
	106	[258]	GETTABLE 	R16 R0 K23 ; R16 := R0["repairedPointDecos"]
	107	[258]	MOVE     	R17 R14 ; R17 := R14
	108	[258]	CALL     	R15 3 1 ; R15(R16,R17)
	109	[239]	TFORLOOP 	R7 2 ; R10,R11 := R7(R8,R9); if R10 ~= nil then begin PC = 16; R9 := R10 end
	110	[261]	JMP      	16 ; PC := 16
	111	[264]	GETGLOBAL	R15 K4 ; R15 := 0x9808fb37
	112	[264]	TEST     	R15 0 ; if not R15 then PC := 144
	113	[264]	JMP      	144 ; PC := 144
	114	[265]	GETGLOBAL	R15 K5 ; R15 := 0x89326c93
	115	[265]	SELF     	R15 R15 K6 ; R16 := R15; R15 := R15[0x9ed3b54e]
	116	[265]	MOVE     	R17 R1 ; R17 := R1
	117	[265]	LOADK    	R18 K24 ; R18 := 0.030000
	118	[265]	GETGLOBAL	R19 K7 ; R19 := 0x60130201
	119	[265]	LOADK    	R20 := 0.000000
	120	[265]	LOADK    	R21 := 100.000000
	121	[265]	LOADK    	R22 := 100.000000
	122	[265]	LOADK    	R23 := 255.000000
	123	[265]	CALL     	R19 5 2 ; R19 := R19(R20,R21,R22,R23)
	124	[265]	GETGLOBAL	R20 K8 ; R20 := 0xf062bfa1
	125	[265]	CALL     	R15 6 1 ; R15(R16,R17,R18,R19,R20)
	126	[266]	GETGLOBAL	R15 K3 ; R15 := 0xc8802016
	127	[266]	GETTABLE 	R16 R0 K17 ; R16 := R0["repairedPoints"]
	128	[266]	CALL     	R15 2 4 ; R15,R16,R17 := R15(R16)
	129	[266]	JMP      	142 ; PC := 142
	130	[267]	GETGLOBAL	R20 K5 ; R20 := 0x89326c93
	131	[267]	SELF     	R20 R20 K6 ; R21 := R20; R20 := R20[0x9ed3b54e]
	132	[267]	MOVE     	R22 R19 ; R22 := R19
	133	[267]	MOVE     	R23 R4 ; R23 := R4
	134	[267]	GETGLOBAL	R24 K7 ; R24 := 0x60130201
	135	[267]	LOADK    	R25 := 0.000000
	136	[267]	LOADK    	R26 := 200.000000
	137	[267]	LOADK    	R27 := 50.000000
	138	[267]	LOADK    	R28 := 255.000000
	139	[267]	CALL     	R24 5 2 ; R24 := R24(R25,R26,R27,R28)
	140	[267]	GETGLOBAL	R25 K8 ; R25 := 0xf062bfa1
	141	[267]	CALL     	R20 6 1 ; R20(R21,R22,R23,R24,R25)
	142	[266]	TFORLOOP 	R15 2 ; R18,R19 := R15(R16,R17); if R18 ~= nil then begin PC = 130; R17 := R18 end
	143	[267]	JMP      	130 ; PC := 130
	144	[270]	RETURN   	R0 1 ; return 

function #14 <?:272,277> (13 instructions, 52 bytes at 00000160E3B12200)
3 params, 7 slots, 2 upvalues, 0 locals, 2 constants, 0 functions
	1	[274]	GETUPVAL 	R3 U0 ; R3 := U0
	2	[274]	MOVE     	R4 R1 ; R4 := R1
	3	[274]	GETTABLE 	R5 R0 K0 ; R5 := R0["boundsMin"]
	4	[274]	GETTABLE 	R6 R0 K1 ; R6 := R0["boundsMax"]
	5	[274]	CALL     	R3 4 2 ; R3 := R3(R4,R5,R6)
	6	[274]	TEST     	R3 0 ; if not R3 then PC := 13
	7	[274]	JMP      	13 ; PC := 13
	8	[275]	GETUPVAL 	R3 U1 ; R3 := U1
	9	[275]	MOVE     	R4 R0 ; R4 := R0
	10	[275]	MOVE     	R5 R1 ; R5 := R1
	11	[275]	MOVE     	R6 R2 ; R6 := R2
	12	[275]	CALL     	R3 4 1 ; R3(R4,R5,R6)
	13	[277]	RETURN   	R0 1 ; return 

function #15 <?:279,312> (142 instructions, 568 bytes at 00000160FF411F10)
1 param, 13 slots, 13 upvalues, 0 locals, 22 constants, 0 functions
	1	[280]	GETUPVAL 	R1 U0 ; R1 := U0
	2	[280]	TEST     	R1 0 ; if not R1 then PC := 53
	3	[280]	JMP      	53 ; PC := 53
	4	[280]	GETUPVAL 	R1 U1 ; R1 := U1
	5	[280]	TEST     	R1 0 ; if not R1 then PC := 53
	6	[280]	JMP      	53 ; PC := 53
	7	[280]	GETUPVAL 	R1 U2 ; R1 := U2
	8	[280]	TEST     	R1 0 ; if not R1 then PC := 53
	9	[280]	JMP      	53 ; PC := 53
	10	[281]	GETGLOBAL	R1 K0 ; R1 := 0x7b998233
	11	[281]	GETUPVAL 	R2 U3 ; R2 := U3
	12	[281]	CALL     	R1 2 2 ; R1 := R1(R2)
	13	[281]	TEST     	R1 1 ; if R1 then PC := 53
	14	[281]	JMP      	53 ; PC := 53
	15	[282]	GETUPVAL 	R1 U4 ; R1 := U4
	16	[282]	CALL     	R1 1 2 ; R1 := R1()
	17	[283]	GETUPVAL 	R2 U5 ; R2 := U5
	18	[283]	TEST     	R2 0 ; if not R2 then PC := 27
	19	[283]	JMP      	27 ; PC := 27
	20	[283]	GETGLOBAL	R2 K1 ; R2 := 0x03ea2485
	21	[283]	GETUPVAL 	R3 U5 ; R3 := U5
	22	[283]	MOVE     	R4 R1 ; R4 := R1
	23	[283]	CALL     	R2 3 2 ; R2 := R2(R3,R4)
	24	[283]	GETUPVAL 	R3 U6 ; R3 := U6
	25	[283]	LE       	0 R3 R2 ; if R3 > R2 then PC := 53
	26	[283]	JMP      	53 ; PC := 53
	27	[284]	GETUPVAL 	R2 U7 ; R2 := U7
	28	[284]	GETUPVAL 	R3 U3 ; R3 := U3
	29	[284]	MOVE     	R4 R1 ; R4 := R1
	30	[284]	GETUPVAL 	R5 U8 ; R5 := U8
	31	[284]	SELF     	R5 R5 K2 ; R6 := R5; R5 := R5[0xd1cbfc3e]
	32	[284]	CALL     	R5 2 0 ; R5,... := R5(R6)
	33	[284]	CALL     	R2 0 1 ; R2(R3,...)
	34	[285]	SETUPVAL 	R1 U5 ; U5 := R1
	35	[287]	GETUPVAL 	R2 U3 ; R2 := U3
	36	[287]	GETTABLE 	R2 R2 K3 ; R2 := R2["points"]
	37	[287]	LEN      	R2 R2 ; R2 := # R2
	38	[287]	GETUPVAL 	R3 U3 ; R3 := U3
	39	[287]	GETTABLE 	R3 R3 K4 ; R3 := R3["repairedPoints"]
	40	[287]	LEN      	R3 R3 ; R3 := # R3
	41	[287]	ADD      	R2 R2 R3 ; R2 := R2 + R3
	42	[288]	GETUPVAL 	R3 U3 ; R3 := U3
	43	[288]	GETTABLE 	R3 R3 K4 ; R3 := R3["repairedPoints"]
	44	[288]	LEN      	R3 R3 ; R3 := # R3
	45	[288]	DIV      	R3 R3 R2 ; R3 := R3 / R2
	46	[289]	GETGLOBAL	R4 K6 ; R4 := 0x5bced4c4
	47	[289]	GETTABLE 	R4 R4 K7 ; R4 := R4[0xac1b386a]
	48	[289]	GETGLOBAL	R5 K8 ; R5 := 0xce2eda5c
	49	[289]	DIV      	R5 R3 R5 ; R5 := R3 / R5
	50	[289]	LOADK    	R6 := 1.000000
	51	[289]	CALL     	R4 3 2 ; R4 := R4(R5,R6)
	52	[289]	SETTABLE 	R0 K5 R4 ; R0["progression"] := R4
	53	[294]	GETUPVAL 	R4 U0 ; R4 := U0
	54	[294]	TEST     	R4 1 ; if R4 then PC := 59
	55	[294]	JMP      	59 ; PC := 59
	56	[294]	GETUPVAL 	R4 U9 ; R4 := U9
	57	[294]	TEST     	R4 0 ; if not R4 then PC := 115
	58	[294]	JMP      	115 ; PC := 115
	59	[294]	GETUPVAL 	R4 U10 ; R4 := U10
	60	[294]	SELF     	R4 R4 K9 ; R5 := R4; R4 := R4[0x9519a807]
	61	[294]	CALL     	R4 2 2 ; R4 := R4(R5)
	62	[294]	TEST     	R4 0 ; if not R4 then PC := 115
	63	[294]	JMP      	115 ; PC := 115
	64	[295]	GETGLOBAL	R4 K0 ; R4 := 0x7b998233
	65	[295]	GETUPVAL 	R5 U3 ; R5 := U3
	66	[295]	CALL     	R4 2 2 ; R4 := R4(R5)
	67	[295]	TEST     	R4 1 ; if R4 then PC := 141
	68	[295]	JMP      	141 ; PC := 141
	69	[295]	GETGLOBAL	R4 K0 ; R4 := 0x7b998233
	70	[295]	GETUPVAL 	R5 U3 ; R5 := U3
	71	[295]	GETTABLE 	R5 R5 K10 ; R5 := R5["projector"]
	72	[295]	CALL     	R4 2 2 ; R4 := R4(R5)
	73	[295]	TEST     	R4 1 ; if R4 then PC := 141
	74	[295]	JMP      	141 ; PC := 141
	75	[296]	GETUPVAL 	R4 U3 ; R4 := U3
	76	[296]	GETTABLE 	R4 R4 K3 ; R4 := R4["points"]
	77	[296]	LEN      	R4 R4 ; R4 := # R4
	78	[296]	GETUPVAL 	R5 U3 ; R5 := U3
	79	[296]	GETTABLE 	R5 R5 K4 ; R5 := R5["repairedPoints"]
	80	[296]	LEN      	R5 R5 ; R5 := # R5
	81	[296]	ADD      	R4 R4 R5 ; R4 := R4 + R5
	82	[297]	LT       	0 K11 R4 ; if 0.000000 >= R4 then PC := 141
	83	[297]	JMP      	141 ; PC := 141
	84	[298]	GETUPVAL 	R5 U3 ; R5 := U3
	85	[298]	GETTABLE 	R5 R5 K3 ; R5 := R5["points"]
	86	[298]	LEN      	R5 R5 ; R5 := # R5
	87	[298]	DIV      	R5 R5 R4 ; R5 := R5 / R4
	88	[299]	GETUPVAL 	R6 U3 ; R6 := U3
	89	[299]	GETTABLE 	R6 R6 K10 ; R6 := R6["projector"]
	90	[299]	SELF     	R6 R6 K12 ; R7 := R6; R6 := R6[0x986d2ab8]
	91	[299]	GETUPVAL 	R8 U11 ; R8 := U11
	92	[299]	MUL      	R9 K13 R5 ; R9 := 40.000000 * R5
	93	[299]	CALL     	R6 4 1 ; R6(R7,R8,R9)
	94	[300]	GETUPVAL 	R6 U3 ; R6 := U3
	95	[300]	GETTABLE 	R6 R6 K10 ; R6 := R6["projector"]
	96	[300]	SELF     	R6 R6 K12 ; R7 := R6; R6 := R6[0x986d2ab8]
	97	[300]	GETUPVAL 	R8 U12 ; R8 := U12
	98	[300]	MUL      	R9 K14 R5 ; R9 := 1.820000 * R5
	99	[300]	ADD      	R9 K15 R9 ; R9 := 0.320000 + R9
	100	[300]	MUL      	R10 K16 R5 ; R10 := 0.300000 * R5
	101	[300]	MUL      	R11 K17 R5 ; R11 := 0.030000 * R5
	102	[300]	LOADK    	R12 := 1.000000
	103	[300]	CALL     	R6 7 1 ; R6(R7,R8,R9,R10,R11,R12)
	104	[301]	GETUPVAL 	R6 U3 ; R6 := U3
	105	[301]	GETTABLE 	R6 R6 K10 ; R6 := R6["projector"]
	106	[301]	SELF     	R6 R6 K18 ; R7 := R6; R6 := R6[0x66472bf5]
	107	[301]	GETGLOBAL	R8 K6 ; R8 := 0x5bced4c4
	108	[301]	GETTABLE 	R8 R8 K19 ; R8 := R8[0xb62ecfe0]
	109	[301]	LOADK    	R9 := 0.000000
	110	[301]	SUB      	R10 K20 R5 ; R10 := 0.400000 - R5
	111	[301]	CALL     	R8 3 2 ; R8 := R8(R9,R10)
	112	[301]	MUL      	R8 K21 R8 ; R8 := 2.500000 * R8
	113	[301]	CALL     	R6 3 1 ; R6(R7,R8)
	114	[303]	JMP      	141 ; PC := 141
	115	[305]	GETGLOBAL	R6 K0 ; R6 := 0x7b998233
	116	[305]	GETUPVAL 	R7 U3 ; R7 := U3
	117	[305]	CALL     	R6 2 2 ; R6 := R6(R7)
	118	[305]	TEST     	R6 1 ; if R6 then PC := 141
	119	[305]	JMP      	141 ; PC := 141
	120	[305]	GETGLOBAL	R6 K0 ; R6 := 0x7b998233
	121	[305]	GETUPVAL 	R7 U3 ; R7 := U3
	122	[305]	GETTABLE 	R7 R7 K10 ; R7 := R7["projector"]
	123	[305]	CALL     	R6 2 2 ; R6 := R6(R7)
	124	[305]	TEST     	R6 1 ; if R6 then PC := 141
	125	[305]	JMP      	141 ; PC := 141
	126	[306]	GETUPVAL 	R6 U3 ; R6 := U3
	127	[306]	GETTABLE 	R6 R6 K10 ; R6 := R6["projector"]
	128	[306]	SELF     	R6 R6 K12 ; R7 := R6; R6 := R6[0x986d2ab8]
	129	[306]	GETUPVAL 	R8 U11 ; R8 := U11
	130	[306]	LOADK    	R9 := 1.000000
	131	[306]	CALL     	R6 4 1 ; R6(R7,R8,R9)
	132	[307]	GETUPVAL 	R6 U3 ; R6 := U3
	133	[307]	GETTABLE 	R6 R6 K10 ; R6 := R6["projector"]
	134	[307]	SELF     	R6 R6 K12 ; R7 := R6; R6 := R6[0x986d2ab8]
	135	[307]	GETUPVAL 	R8 U12 ; R8 := U12
	136	[307]	LOADK    	R9 K15 ; R9 := 0.320000
	137	[307]	LOADK    	R10 := 0.000000
	138	[307]	LOADK    	R11 := 0.000000
	139	[307]	LOADK    	R12 := 1.000000
	140	[307]	CALL     	R6 7 1 ; R6(R7,R8,R9,R10,R11,R12)
	141	[311]	RETURN   	R0 2 ; return R0 
	142	[312]	RETURN   	R0 1 ; return 

function #16 <?:318,366> (127 instructions, 508 bytes at 00000160E39825F0)
1 param, 16 slots, 12 upvalues, 0 locals, 21 constants, 0 functions
	1	[319]	GETGLOBAL	R1 K0 ; R1 := 0x67652851
	2	[319]	CALL     	R1 1 2 ; R1 := R1()
	3	[320]	GETGLOBAL	R2 K1 ; R2 := 0x7b998233
	4	[320]	GETTABLE 	R3 R0 K2 ; R3 := R0["lastUpdateTime"]
	5	[320]	CALL     	R2 2 2 ; R2 := R2(R3)
	6	[320]	TEST     	R2 1 ; if R2 then PC := 19
	7	[320]	JMP      	19 ; PC := 19
	8	[320]	GETTABLE 	R2 R0 K3 ; R2 := R0["progressionDirection"]
	9	[320]	LT       	0 R2 K4 ; if R2 >= 0.000000 then PC := 19
	10	[320]	JMP      	19 ; PC := 19
	11	[321]	GETGLOBAL	R2 K5 ; R2 := 0x55156ff7
	12	[321]	CALL     	R2 1 2 ; R2 := R2()
	13	[322]	GETGLOBAL	R3 K5 ; R3 := 0x55156ff7
	14	[322]	CALL     	R3 1 2 ; R3 := R3()
	15	[322]	GETTABLE 	R4 R0 K2 ; R4 := R0["lastUpdateTime"]
	16	[322]	SUB      	R1 R3 R4 ; R1 := R3 - R4
	17	[323]	SETTABLE 	R0 K2 R2 ; R0["lastUpdateTime"] := R2
	18	[323]	JMP      	22 ; PC := 22
	19	[325]	GETGLOBAL	R3 K5 ; R3 := 0x55156ff7
	20	[325]	CALL     	R3 1 2 ; R3 := R3()
	21	[325]	SETTABLE 	R0 K2 R3 ; R0["lastUpdateTime"] := R3
	22	[327]	GETUPVAL 	R3 U0 ; R3 := U0
	23	[328]	GETUPVAL 	R4 U1 ; R4 := U1
	24	[328]	TEST     	R4 0 ; if not R4 then PC := 27
	25	[328]	JMP      	27 ; PC := 27
	26	[329]	GETUPVAL 	R3 U2 ; R3 := U2
	27	[331]	MUL      	R4 R3 R1 ; R4 := R3 * R1
	28	[332]	GETTABLE 	R5 R0 K3 ; R5 := R0["progressionDirection"]
	29	[333]	GETUPVAL 	R6 U3 ; R6 := U3
	30	[333]	TEST     	R6 0 ; if not R6 then PC := 36
	31	[333]	JMP      	36 ; PC := 36
	32	[333]	GETUPVAL 	R6 U4 ; R6 := U4
	33	[333]	TEST     	R6 0 ; if not R6 then PC := 36
	34	[333]	JMP      	36 ; PC := 36
	35	[333]	GETUPVAL 	R6 U5 ; R6 := U5
	36	[334]	GETTABLE 	R7 R0 K6 ; R7 := R0["progression"]
	37	[335]	TEST     	R6 0 ; if not R6 then PC := 57
	38	[335]	JMP      	57 ; PC := 57
	39	[335]	LT       	0 K4 R5 ; if 0.000000 >= R5 then PC := 57
	40	[335]	JMP      	57 ; PC := 57
	41	[336]	LOADK    	R8 K7 ; R8 := 0.050000
	42	[337]	GETGLOBAL	R9 K8 ; R9 := 0x5bced4c4
	43	[337]	GETTABLE 	R9 R9 K9 ; R9 := R9[0xb62ecfe0]
	44	[337]	GETTABLE 	R10 R0 K6 ; R10 := R0["progression"]
	45	[337]	SUB      	R10 K10 R10 ; R10 := 1.000000 - R10
	46	[337]	MOVE     	R11 R8 ; R11 := R8
	47	[337]	CALL     	R9 3 2 ; R9 := R9(R10,R11)
	48	[338]	MUL      	R4 R4 R9 ; R4 := R4 * R9
	49	[339]	GETGLOBAL	R10 K8 ; R10 := 0x5bced4c4
	50	[339]	GETTABLE 	R10 R10 K11 ; R10 := R10[0xac1b386a]
	51	[339]	GETTABLE 	R11 R0 K6 ; R11 := R0["progression"]
	52	[339]	ADD      	R11 R11 R4 ; R11 := R11 + R4
	53	[339]	LOADK    	R12 := 1.000000
	54	[339]	CALL     	R10 3 2 ; R10 := R10(R11,R12)
	55	[339]	SETTABLE 	R0 K6 R10 ; R0["progression"] := R10
	56	[339]	JMP      	120 ; PC := 120
	57	[341]	GETUPVAL 	R10 U6 ; R10 := U6
	58	[341]	TEST     	R10 0 ; if not R10 then PC := 82
	59	[341]	JMP      	82 ; PC := 82
	60	[341]	GETUPVAL 	R10 U4 ; R10 := U4
	61	[341]	TEST     	R10 1 ; if R10 then PC := 82
	62	[341]	JMP      	82 ; PC := 82
	63	[341]	LT       	0 K4 R5 ; if 0.000000 >= R5 then PC := 82
	64	[341]	JMP      	82 ; PC := 82
	65	[342]	GETUPVAL 	R10 U7 ; R10 := U7
	66	[342]	GETTABLE 	R11 R0 K12 ; R11 := R0["sweetSpot"]
	67	[342]	GETTABLE 	R12 R0 K6 ; R12 := R0["progression"]
	68	[342]	CALL     	R10 3 2 ; R10 := R10(R11,R12)
	69	[342]	TEST     	R10 0 ; if not R10 then PC := 77
	70	[342]	JMP      	77 ; PC := 77
	71	[343]	GETUPVAL 	R10 U8 ; R10 := U8
	72	[343]	LOADK    	R11 K13 ; R11 := "Hit sweet spot."
	73	[343]	CALL     	R10 2 1 ; R10(R11)
	74	[344]	GETUPVAL 	R10 U9 ; R10 := U9
	75	[344]	CALL     	R10 1 1 ; R10()
	76	[344]	JMP      	120 ; PC := 120
	77	[346]	GETUPVAL 	R10 U8 ; R10 := U8
	78	[346]	LOADK    	R11 K14 ; R11 := "Retreat progress."
	79	[346]	CALL     	R10 2 1 ; R10(R11)
	80	[347]	SETTABLE 	R0 K3 K15 ; R0["progressionDirection"] := -1.000000
	81	[348]	JMP      	120 ; PC := 120
	82	[349]	LT       	0 K4 R5 ; if 0.000000 >= R5 then PC := 94
	83	[349]	JMP      	94 ; PC := 94
	84	[349]	GETTABLE 	R10 R0 K6 ; R10 := R0["progression"]
	85	[349]	LT       	0 K4 R10 ; if 0.000000 >= R10 then PC := 94
	86	[349]	JMP      	94 ; PC := 94
	87	[349]	TEST     	R6 1 ; if R6 then PC := 94
	88	[349]	JMP      	94 ; PC := 94
	89	[350]	GETUPVAL 	R10 U8 ; R10 := U8
	90	[350]	LOADK    	R11 K14 ; R11 := "Retreat progress."
	91	[350]	CALL     	R10 2 1 ; R10(R11)
	92	[351]	SETTABLE 	R0 K3 K15 ; R0["progressionDirection"] := -1.000000
	93	[351]	JMP      	120 ; PC := 120
	94	[352]	LT       	0 R5 K4 ; if R5 >= 0.000000 then PC := 120
	95	[352]	JMP      	120 ; PC := 120
	96	[353]	GETGLOBAL	R10 K8 ; R10 := 0x5bced4c4
	97	[353]	GETTABLE 	R10 R10 K9 ; R10 := R10[0xb62ecfe0]
	98	[353]	GETTABLE 	R11 R0 K6 ; R11 := R0["progression"]
	99	[353]	SUB      	R11 R11 R4 ; R11 := R11 - R4
	100	[353]	LOADK    	R12 := 0.000000
	101	[353]	CALL     	R10 3 2 ; R10 := R10(R11,R12)
	102	[353]	SETTABLE 	R0 K6 R10 ; R0["progression"] := R10
	103	[354]	GETTABLE 	R10 R0 K6 ; R10 := R0["progression"]
	104	[354]	LE       	0 R10 K4 ; if R10 > 0.000000 then PC := 120
	105	[354]	JMP      	120 ; PC := 120
	106	[355]	GETUPVAL 	R10 U8 ; R10 := U8
	107	[355]	LOADK    	R11 K16 ; R11 := "Reset direction."
	108	[355]	CALL     	R10 2 1 ; R10(R11)
	109	[356]	GETUPVAL 	R10 U10 ; R10 := U10
	110	[356]	CALL     	R10 1 3 ; R10,R11 := R10()
	111	[357]	NEWTABLE 	R12 0 2 ; R12 := {}
	112	[357]	SETTABLE 	R12 K18 R10 ; R12["START"] := R10
	113	[357]	SETTABLE 	R12 K19 R11 ; R12["END"] := R11
	114	[357]	SETTABLE 	R0 K17 R12 ; R0["baseSweetSpot"] := R12
	115	[358]	NEWTABLE 	R12 0 2 ; R12 := {}
	116	[358]	SETTABLE 	R12 K18 R10 ; R12["START"] := R10
	117	[358]	SETTABLE 	R12 K19 R11 ; R12["END"] := R11
	118	[358]	SETTABLE 	R0 K12 R12 ; R0["sweetSpot"] := R12
	119	[359]	SETTABLE 	R0 K3 K10 ; R0["progressionDirection"] := 1.000000
	120	[363]	GETUPVAL 	R12 U11 ; R12 := U11
	121	[363]	GETTABLE 	R13 R0 K12 ; R13 := R0["sweetSpot"]
	122	[363]	MOVE     	R14 R7 ; R14 := R7
	123	[363]	GETTABLE 	R15 R0 K6 ; R15 := R0["progression"]
	124	[363]	CALL     	R12 4 2 ; R12 := R12(R13,R14,R15)
	125	[363]	SETTABLE 	R0 K20 R12 ; R0["enteredSweetSpot"] := R12
	126	[365]	RETURN   	R0 2 ; return R0 
	127	[366]	RETURN   	R0 1 ; return 

function #17 <?:372,390> (51 instructions, 204 bytes at 0000016098C745B0)
0 params, 13 slots, 4 upvalues, 0 locals, 15 constants, 0 functions
	1	[373]	GETUPVAL 	R0 U0 ; R0 := U0
	2	[373]	SELF     	R0 R0 K0 ; R1 := R0; R0 := R0[0x7c09e541]
	3	[373]	CALL     	R0 2 2 ; R0 := R0(R1)
	4	[374]	GETUPVAL 	R1 U0 ; R1 := U0
	5	[374]	SELF     	R1 R1 K1 ; R2 := R1; R1 := R1[0x20149084]
	6	[374]	GETUPVAL 	R3 U1 ; R3 := U1
	7	[374]	CALL     	R1 3 2 ; R1 := R1(R2,R3)
	8	[375]	GETGLOBAL	R2 K2 ; R2 := 0x7b998233
	9	[375]	MOVE     	R3 R0 ; R3 := R0
	10	[375]	CALL     	R2 2 2 ; R2 := R2(R3)
	11	[375]	TEST     	R2 1 ; if R2 then PC := 50
	12	[375]	JMP      	50 ; PC := 50
	13	[375]	SELF     	R2 R0 K3 ; R3 := R0; R2 := R0[0xf2deaf69]
	14	[375]	GETGLOBAL	R4 K4 ; R4 := 0xdb331825
	15	[375]	CALL     	R2 3 2 ; R2 := R2(R3,R4)
	16	[375]	TEST     	R2 0 ; if not R2 then PC := 50
	17	[375]	JMP      	50 ; PC := 50
	18	[376]	NEWTABLE 	R2 4 0 ; R2 := {}
	19	[376]	GETGLOBAL	R3 K5 ; R3 := gBaseAvatarType
	20	[376]	GETGLOBAL	R4 K6 ; R4 := gPickUpType
	21	[376]	GETGLOBAL	R5 K7 ; R5 := gRagdollType
	22	[376]	GETGLOBAL	R6 K8 ; R6 := gHitProxyType
	23	[376]	SETLIST  	R2 4 1 ; R2[(1-1)*FPF+i] := R(2+i), 1 <= i <= 4
	24	[377]	GETUPVAL 	R3 U2 ; R3 := U2
	25	[377]	SELF     	R3 R3 K9 ; R4 := R3; R3 := R3[0xd3a01177]
	26	[377]	CALL     	R3 2 2 ; R3 := R3(R4)
	27	[377]	SELF     	R3 R3 K10 ; R4 := R3; R3 := R3[0xd1cbfc3e]
	28	[377]	CALL     	R3 2 2 ; R3 := R3(R4)
	29	[378]	GETGLOBAL	R4 K11 ; R4 := 0xc2892f65
	30	[378]	MOVE     	R5 R3 ; R5 := R3
	31	[378]	CALL     	R4 2 1 ; R4(R5)
	32	[379]	GETUPVAL 	R4 U3 ; R4 := U3
	33	[379]	MUL      	R4 R3 R4 ; R4 := R3 * R4
	34	[379]	ADD      	R4 R1 R4 ; R4 := R1 + R4
	35	[380]	GETGLOBAL	R5 K12 ; R5 := 0xa421af95
	36	[380]	CALL     	R5 1 2 ; R5 := R5()
	37	[381]	GETGLOBAL	R6 K13 ; R6 := 0x89326c93
	38	[381]	SELF     	R6 R6 K14 ; R7 := R6; R6 := R6[0x722cd32c]
	39	[381]	MOVE     	R8 R1 ; R8 := R1
	40	[381]	MOVE     	R9 R4 ; R9 := R4
	41	[381]	MOVE     	R10 R2 ; R10 := R2
	42	[381]	LOADNIL  	R11 R11 ; R11 := nil
	43	[381]	MOVE     	R12 R5 ; R12 := R5
	44	[381]	CALL     	R6 7 2 ; R6 := R6(R7,R8,R9,R10,R11,R12)
	45	[382]	TEST     	R6 0 ; if not R6 then PC := 49
	46	[382]	JMP      	49 ; PC := 49
	47	[383]	RETURN   	R5 2 ; return R5 
	48	[383]	JMP      	50 ; PC := 50
	49	[385]	RETURN   	R1 2 ; return R1 
	50	[389]	RETURN   	R1 2 ; return R1 
	51	[390]	RETURN   	R0 1 ; return 

function #18 <?:392,404> (43 instructions, 172 bytes at 0000016098C74640)
0 params, 6 slots, 4 upvalues, 0 locals, 6 constants, 0 functions
	1	[393]	GETGLOBAL	R0 K0 ; R0 := 0x7b998233
	2	[393]	GETUPVAL 	R1 U0 ; R1 := U0
	3	[393]	CALL     	R0 2 2 ; R0 := R0(R1)
	4	[393]	TEST     	R0 1 ; if R0 then PC := 41
	5	[393]	JMP      	41 ; PC := 41
	6	[393]	GETGLOBAL	R0 K0 ; R0 := 0x7b998233
	7	[393]	GETUPVAL 	R1 U1 ; R1 := U1
	8	[393]	CALL     	R0 2 2 ; R0 := R0(R1)
	9	[393]	TEST     	R0 1 ; if R0 then PC := 41
	10	[393]	JMP      	41 ; PC := 41
	11	[394]	GETUPVAL 	R0 U0 ; R0 := U0
	12	[394]	SELF     	R0 R0 K1 ; R1 := R0; R0 := R0[0x7c09e541]
	13	[394]	CALL     	R0 2 2 ; R0 := R0(R1)
	14	[395]	GETGLOBAL	R1 K0 ; R1 := 0x7b998233
	15	[395]	MOVE     	R2 R0 ; R2 := R0
	16	[395]	CALL     	R1 2 2 ; R1 := R1(R2)
	17	[395]	TEST     	R1 1 ; if R1 then PC := 41
	18	[395]	JMP      	41 ; PC := 41
	19	[395]	SELF     	R1 R0 K2 ; R2 := R0; R1 := R0[0xf2deaf69]
	20	[395]	GETGLOBAL	R3 K3 ; R3 := 0xdb331825
	21	[395]	CALL     	R1 3 2 ; R1 := R1(R2,R3)
	22	[395]	TEST     	R1 0 ; if not R1 then PC := 41
	23	[395]	JMP      	41 ; PC := 41
	24	[396]	SELF     	R1 R0 K4 ; R2 := R0; R1 := R0[0x2b54251b]
	25	[396]	CALL     	R1 2 2 ; R1 := R1(R2)
	26	[397]	GETUPVAL 	R2 U2 ; R2 := U2
	27	[397]	CALL     	R2 1 2 ; R2 := R2()
	28	[398]	GETGLOBAL	R3 K0 ; R3 := 0x7b998233
	29	[398]	MOVE     	R4 R1 ; R4 := R1
	30	[398]	CALL     	R3 2 2 ; R3 := R3(R4)
	31	[398]	TEST     	R3 1 ; if R3 then PC := 41
	32	[398]	JMP      	41 ; PC := 41
	33	[398]	GETUPVAL 	R3 U1 ; R3 := U1
	34	[398]	SELF     	R3 R3 K5 ; R4 := R3; R3 := R3[0x1f420a3a]
	35	[398]	MOVE     	R5 R2 ; R5 := R2
	36	[398]	CALL     	R3 3 2 ; R3 := R3(R4,R5)
	37	[398]	GETUPVAL 	R4 U3 ; R4 := U3
	38	[398]	LE       	0 R3 R4 ; if R3 > R4 then PC := 41
	39	[398]	JMP      	41 ; PC := 41
	40	[399]	RETURN   	R1 2 ; return R1 
	41	[403]	LOADNIL  	R3 R3 ; R3 := nil
	42	[403]	RETURN   	R3 2 ; return R3 
	43	[404]	RETURN   	R0 1 ; return 

function #19 <?:406,422> (48 instructions, 192 bytes at 0000016098C74740)
1 param, 5 slots, 8 upvalues, 0 locals, 5 constants, 0 functions
	1	[407]	GETGLOBAL	R1 K0 ; R1 := 0x7b998233
	2	[407]	GETUPVAL 	R2 U0 ; R2 := U0
	3	[407]	CALL     	R1 2 2 ; R1 := R1(R2)
	4	[407]	TEST     	R1 1 ; if R1 then PC := 18
	5	[407]	JMP      	18 ; PC := 18
	6	[407]	GETGLOBAL	R1 K0 ; R1 := 0x7b998233
	7	[407]	GETUPVAL 	R2 U0 ; R2 := U0
	8	[407]	GETTABLE 	R2 R2 K1 ; R2 := R2["projector"]
	9	[407]	CALL     	R1 2 2 ; R1 := R1(R2)
	10	[407]	TEST     	R1 1 ; if R1 then PC := 18
	11	[407]	JMP      	18 ; PC := 18
	12	[408]	GETUPVAL 	R1 U0 ; R1 := U0
	13	[408]	GETTABLE 	R1 R1 K1 ; R1 := R1["projector"]
	14	[408]	SELF     	R1 R1 K2 ; R2 := R1; R1 := R1[0x986d2ab8]
	15	[408]	GETUPVAL 	R3 U1 ; R3 := U1
	16	[408]	LOADK    	R4 := 1.000000
	17	[408]	CALL     	R1 4 1 ; R1(R2,R3,R4)
	18	[410]	GETGLOBAL	R1 K0 ; R1 := 0x7b998233
	19	[410]	MOVE     	R2 R0 ; R2 := R0
	20	[410]	CALL     	R1 2 2 ; R1 := R1(R2)
	21	[410]	TEST     	R1 1 ; if R1 then PC := 46
	22	[410]	JMP      	46 ; PC := 46
	23	[411]	GETUPVAL 	R1 U2 ; R1 := U2
	24	[411]	LOADK    	R2 K3 ; R2 := "Get new target info"
	25	[411]	CALL     	R1 2 1 ; R1(R2)
	26	[412]	GETUPVAL 	R1 U4 ; R1 := U4
	27	[412]	MOVE     	R2 R0 ; R2 := R0
	28	[412]	CALL     	R1 2 2 ; R1 := R1(R2)
	29	[412]	SETUPVAL 	R1 U3 ; U3 := R1
	30	[413]	GETUPVAL 	R1 U5 ; R1 := U5
	31	[413]	MOVE     	R2 R0 ; R2 := R0
	32	[413]	CALL     	R1 2 2 ; R1 := R1(R2)
	33	[413]	TEST     	R1 0 ; if not R1 then PC := 43
	34	[413]	JMP      	43 ; PC := 43
	35	[414]	GETUPVAL 	R1 U2 ; R1 := U2
	36	[414]	LOADK    	R2 K4 ; R2 := "Get new TargettedWallBreachInfo"
	37	[414]	CALL     	R1 2 1 ; R1(R2)
	38	[415]	GETUPVAL 	R1 U6 ; R1 := U6
	39	[415]	GETUPVAL 	R2 U7 ; R2 := U7
	40	[415]	CALL     	R1 2 2 ; R1 := R1(R2)
	41	[415]	SETUPVAL 	R1 U0 ; U0 := R1
	42	[415]	JMP      	48 ; PC := 48
	43	[417]	LOADNIL  	R1 R1 ; R1 := nil
	44	[417]	SETUPVAL 	R1 U0 ; U0 := R1
	45	[418]	JMP      	48 ; PC := 48
	46	[420]	LOADNIL  	R1 R1 ; R1 := nil
	47	[420]	SETUPVAL 	R1 U3 ; U3 := R1
	48	[422]	RETURN   	R0 1 ; return 

function #20 <?:424,447> (58 instructions, 232 bytes at 0000016098C74880)
0 params, 7 slots, 5 upvalues, 0 locals, 13 constants, 0 functions
	1	[425]	GETUPVAL 	R0 U0 ; R0 := U0
	2	[425]	LOADK    	R1 K0 ; R1 := "FinishRepair"
	3	[425]	CALL     	R0 2 1 ; R0(R1)
	4	[426]	GETGLOBAL	R0 K1 ; R0 := 0x7b998233
	5	[426]	GETUPVAL 	R1 U1 ; R1 := U1
	6	[426]	CALL     	R0 2 2 ; R0 := R0(R1)
	7	[426]	TEST     	R0 1 ; if R0 then PC := 56
	8	[426]	JMP      	56 ; PC := 56
	9	[427]	GETUPVAL 	R0 U1 ; R0 := U1
	10	[427]	GETTABLE 	R0 R0 K2 ; R0 := R0["target"]
	11	[428]	GETGLOBAL	R1 K1 ; R1 := 0x7b998233
	12	[428]	MOVE     	R2 R0 ; R2 := R0
	13	[428]	CALL     	R1 2 2 ; R1 := R1(R2)
	14	[428]	TEST     	R1 1 ; if R1 then PC := 56
	15	[428]	JMP      	56 ; PC := 56
	16	[429]	SELF     	R1 R0 K3 ; R2 := R0; R1 := R0[0xed4e0128]
	17	[429]	CALL     	R1 2 2 ; R1 := R1(R2)
	18	[430]	GETGLOBAL	R2 K1 ; R2 := 0x7b998233
	19	[430]	GETGLOBAL	R3 K4 ; R3 := 0xcb79539e
	20	[430]	CALL     	R2 2 2 ; R2 := R2(R3)
	21	[430]	TEST     	R2 1 ; if R2 then PC := 30
	22	[430]	JMP      	30 ; PC := 30
	23	[431]	GETGLOBAL	R2 K4 ; R2 := 0xcb79539e
	24	[431]	SELF     	R2 R2 K5 ; R3 := R2; R2 := R2[0x8b8fb8b7]
	25	[431]	GETGLOBAL	R4 K6 ; R4 := 0x0469f296
	26	[431]	LOADK    	R5 K7 ; R5 := "RAILJACK_REPAIRS"
	27	[431]	CALL     	R4 2 2 ; R4 := R4(R5)
	28	[431]	MOVE     	R5 R1 ; R5 := R1
	29	[431]	CALL     	R2 4 1 ; R2(R3,R4,R5)
	30	[434]	SELF     	R2 R0 K8 ; R3 := R0; R2 := R0[0xf2deaf69]
	31	[434]	GETGLOBAL	R4 K9 ; R4 := 0xa5dc8da5
	32	[434]	CALL     	R2 3 2 ; R2 := R2(R3,R4)
	33	[434]	TEST     	R2 0 ; if not R2 then PC := 41
	34	[434]	JMP      	41 ; PC := 41
	35	[435]	SELF     	R2 R0 K10 ; R3 := R0; R2 := R0[0xa2880940]
	36	[435]	CALL     	R2 2 1 ; R2(R3)
	37	[436]	GETUPVAL 	R2 U2 ; R2 := U2
	38	[436]	LOADNIL  	R3 R3 ; R3 := nil
	39	[436]	CALL     	R2 2 1 ; R2(R3)
	40	[436]	JMP      	56 ; PC := 56
	41	[438]	GETUPVAL 	R2 U3 ; R2 := U3
	42	[438]	GETTABLE 	R2 R2 K11 ; R2 := R2[0x81e6c00c]
	43	[438]	CALL     	R2 1 2 ; R2 := R2()
	44	[439]	GETGLOBAL	R3 K1 ; R3 := 0x7b998233
	45	[439]	MOVE     	R4 R2 ; R4 := R2
	46	[439]	CALL     	R3 2 2 ; R3 := R3(R4)
	47	[439]	TEST     	R3 1 ; if R3 then PC := 56
	48	[439]	JMP      	56 ; PC := 56
	49	[440]	SELF     	R3 R2 K12 ; R4 := R2; R3 := R2[0xaa0a8cef]
	50	[440]	MOVE     	R5 R0 ; R5 := R0
	51	[440]	GETUPVAL 	R6 U4 ; R6 := U4
	52	[440]	CALL     	R3 4 1 ; R3(R4,R5,R6)
	53	[441]	GETUPVAL 	R3 U2 ; R3 := U2
	54	[441]	LOADNIL  	R4 R4 ; R4 := nil
	55	[441]	CALL     	R3 2 1 ; R3(R4)
	56	[446]	LOADNIL  	R3 R3 ; R3 := nil
	57	[446]	SETUPVAL 	R3 U1 ; U1 := R3
	58	[447]	RETURN   	R0 1 ; return 

function #21 <?:449,501> (149 instructions, 596 bytes at 0000016098C74910)
0 params, 7 slots, 19 upvalues, 0 locals, 17 constants, 0 functions
	1	[450]	GETGLOBAL	R0 K0 ; R0 := 0x7b998233
	2	[450]	GETUPVAL 	R1 U0 ; R1 := U0
	3	[450]	CALL     	R0 2 2 ; R0 := R0(R1)
	4	[450]	TEST     	R0 0 ; if not R0 then PC := 10
	5	[450]	JMP      	10 ; PC := 10
	6	[451]	GETUPVAL 	R0 U1 ; R0 := U1
	7	[451]	SELF     	R0 R0 K1 ; R1 := R0; R0 := R0[0xd3a01177]
	8	[451]	CALL     	R0 2 2 ; R0 := R0(R1)
	9	[451]	SETUPVAL 	R0 U0 ; U0 := R0
	10	[454]	GETGLOBAL	R0 K0 ; R0 := 0x7b998233
	11	[454]	GETUPVAL 	R1 U0 ; R1 := U0
	12	[454]	CALL     	R0 2 2 ; R0 := R0(R1)
	13	[454]	TEST     	R0 1 ; if R0 then PC := 30
	14	[454]	JMP      	30 ; PC := 30
	15	[454]	GETGLOBAL	R0 K0 ; R0 := 0x7b998233
	16	[454]	GETUPVAL 	R1 U2 ; R1 := U2
	17	[454]	CALL     	R0 2 2 ; R0 := R0(R1)
	18	[454]	TEST     	R0 1 ; if R0 then PC := 30
	19	[454]	JMP      	30 ; PC := 30
	20	[454]	GETGLOBAL	R0 K0 ; R0 := 0x7b998233
	21	[454]	GETUPVAL 	R1 U3 ; R1 := U3
	22	[454]	CALL     	R0 2 2 ; R0 := R0(R1)
	23	[454]	TEST     	R0 1 ; if R0 then PC := 30
	24	[454]	JMP      	30 ; PC := 30
	25	[454]	GETGLOBAL	R0 K0 ; R0 := 0x7b998233
	26	[454]	GETUPVAL 	R1 U1 ; R1 := U1
	27	[454]	CALL     	R0 2 2 ; R0 := R0(R1)
	28	[454]	TEST     	R0 0 ; if not R0 then PC := 31
	29	[454]	JMP      	31 ; PC := 31
	30	[455]	RETURN   	R0 1 ; return 
	31	[458]	GETUPVAL 	R0 U4 ; R0 := U4
	32	[459]	GETUPVAL 	R1 U5 ; R1 := U5
	33	[459]	CALL     	R1 1 2 ; R1 := R1()
	34	[459]	SETUPVAL 	R1 U4 ; U4 := R1
	35	[460]	GETUPVAL 	R1 U4 ; R1 := U4
	36	[460]	EQ       	0 R1 R0 ; if R1 ~= R0 then PC := 39
	37	[460]	JMP      	39 ; PC := 39
	38	[460]	OP_LOADBOOL	R1 0 1 ; R1 := false; PC := 39
	39	[460]	OP_LOADBOOL	R1 1 0 ; R1 := true
	40	[462]	TEST     	R1 0 ; if not R1 then PC := 54
	41	[462]	JMP      	54 ; PC := 54
	42	[463]	GETUPVAL 	R2 U6 ; R2 := U6
	43	[463]	LOADK    	R3 K2 ; R3 := "New Target on MultiTool IsNull? "
	44	[463]	GETGLOBAL	R4 K3 ; R4 := 0x64fb1586
	45	[463]	GETGLOBAL	R5 K0 ; R5 := 0x7b998233
	46	[463]	GETUPVAL 	R6 U4 ; R6 := U4
	47	[463]	CALL     	R5 2 0 ; R5,... := R5(R6)
	48	[463]	CALL     	R4 0 2 ; R4 := R4(R5,...)
	49	[463]	CONCAT   	R3 R3 R4 ; R3 := R3 .. R4
	50	[463]	CALL     	R2 2 1 ; R2(R3)
	51	[464]	GETUPVAL 	R2 U7 ; R2 := U7
	52	[464]	GETUPVAL 	R3 U4 ; R3 := U4
	53	[464]	CALL     	R2 2 1 ; R2(R3)
	54	[467]	GETUPVAL 	R2 U8 ; R2 := U8
	55	[468]	GETUPVAL 	R3 U3 ; R3 := U3
	56	[468]	SELF     	R3 R3 K4 ; R4 := R3; R3 := R3[0x7d4b71b1]
	57	[468]	CALL     	R3 2 2 ; R3 := R3(R4)
	58	[468]	SETUPVAL 	R3 U8 ; U8 := R3
	59	[469]	GETUPVAL 	R3 U8 ; R3 := U8
	60	[469]	EQ       	0 R3 R2 ; if R3 ~= R2 then PC := 63
	61	[469]	JMP      	63 ; PC := 63
	62	[469]	OP_LOADBOOL	R3 0 1 ; R3 := false; PC := 63
	63	[469]	OP_LOADBOOL	R3 1 0 ; R3 := true
	64	[469]	SETUPVAL 	R3 U9 ; U9 := R3
	65	[470]	GETUPVAL 	R3 U1 ; R3 := U1
	66	[470]	SELF     	R3 R3 K5 ; R4 := R3; R3 := R3[0x0e46e45b]
	67	[470]	LOADK    	R5 := 0.000000
	68	[470]	CALL     	R3 3 2 ; R3 := R3(R4,R5)
	69	[470]	SETUPVAL 	R3 U10 ; U10 := R3
	70	[472]	OP_LOADBOOL	R3 0 0 ; R3 := false
	71	[472]	SETUPVAL 	R3 U11 ; U11 := R3
	72	[473]	GETGLOBAL	R3 K0 ; R3 := 0x7b998233
	73	[473]	GETUPVAL 	R4 U4 ; R4 := U4
	74	[473]	CALL     	R3 2 2 ; R3 := R3(R4)
	75	[473]	TEST     	R3 1 ; if R3 then PC := 79
	76	[473]	JMP      	79 ; PC := 79
	77	[474]	OP_LOADBOOL	R3 1 0 ; R3 := true
	78	[474]	SETUPVAL 	R3 U11 ; U11 := R3
	79	[477]	GETGLOBAL	R3 K0 ; R3 := 0x7b998233
	80	[477]	GETUPVAL 	R4 U4 ; R4 := U4
	81	[477]	CALL     	R3 2 2 ; R3 := R3(R4)
	82	[477]	TEST     	R3 1 ; if R3 then PC := 132
	83	[477]	JMP      	132 ; PC := 132
	84	[477]	GETGLOBAL	R3 K0 ; R3 := 0x7b998233
	85	[477]	GETUPVAL 	R4 U12 ; R4 := U12
	86	[477]	CALL     	R3 2 2 ; R3 := R3(R4)
	87	[477]	TEST     	R3 1 ; if R3 then PC := 132
	88	[477]	JMP      	132 ; PC := 132
	89	[478]	GETUPVAL 	R3 U4 ; R3 := U4
	90	[478]	SELF     	R3 R3 K7 ; R4 := R3; R3 := R3[0x0454650e]
	91	[478]	CALL     	R3 2 2 ; R3 := R3(R4)
	92	[479]	GETGLOBAL	R4 K0 ; R4 := 0x7b998233
	93	[479]	GETGLOBAL	R5 K8 ; R5 := _T
	94	[479]	GETTABLE 	R5 R5 K9 ; R5 := R5["multiToolAmmoReduction"]
	95	[479]	CALL     	R4 2 2 ; R4 := R4(R5)
	96	[479]	TEST     	R4 1 ; if R4 then PC := 101
	97	[479]	JMP      	101 ; PC := 101
	98	[480]	GETGLOBAL	R4 K8 ; R4 := _T
	99	[480]	GETTABLE 	R4 R4 K9 ; R4 := R4["multiToolAmmoReduction"]
	100	[480]	MUL      	R3 R3 R4 ; R3 := R3 * R4
	101	[482]	GETUPVAL 	R4 U14 ; R4 := U14
	102	[482]	CALL     	R4 1 2 ; R4 := R4()
	103	[482]	LE       	1 R3 R4 ; if R3 <= R4 then PC := 106
	104	[482]	JMP      	106 ; PC := 106
	105	[482]	OP_LOADBOOL	R4 0 1 ; R4 := false; PC := 106
	106	[482]	OP_LOADBOOL	R4 1 0 ; R4 := true
	107	[482]	SETUPVAL 	R4 U13 ; U13 := R4
	108	[483]	GETUPVAL 	R4 U15 ; R4 := U15
	109	[483]	GETUPVAL 	R5 U4 ; R5 := U4
	110	[483]	CALL     	R4 2 2 ; R4 := R4(R5)
	111	[483]	TEST     	R4 0 ; if not R4 then PC := 118
	112	[483]	JMP      	118 ; PC := 118
	113	[484]	GETUPVAL 	R4 U16 ; R4 := U16
	114	[484]	GETUPVAL 	R5 U12 ; R5 := U12
	115	[484]	CALL     	R4 2 2 ; R4 := R4(R5)
	116	[484]	SETUPVAL 	R4 U12 ; U12 := R4
	117	[484]	JMP      	122 ; PC := 122
	118	[486]	GETUPVAL 	R4 U17 ; R4 := U17
	119	[486]	GETUPVAL 	R5 U12 ; R5 := U12
	120	[486]	CALL     	R4 2 2 ; R4 := R4(R5)
	121	[486]	SETUPVAL 	R4 U12 ; U12 := R4
	122	[489]	GETUPVAL 	R4 U12 ; R4 := U12
	123	[489]	GETTABLE 	R4 R4 K10 ; R4 := R4["progression"]
	124	[489]	LE       	0 K11 R4 ; if 1.000000 > R4 then PC := 136
	125	[489]	JMP      	136 ; PC := 136
	126	[490]	GETUPVAL 	R4 U6 ; R4 := U6
	127	[490]	LOADK    	R5 K12 ; R5 := "mCurrentTargetRepairInfo.progression >= 1.0"
	128	[490]	CALL     	R4 2 1 ; R4(R5)
	129	[491]	GETUPVAL 	R4 U18 ; R4 := U18
	130	[491]	CALL     	R4 1 1 ; R4()
	131	[492]	JMP      	136 ; PC := 136
	132	[494]	LOADNIL  	R4 R4 ; R4 := nil
	133	[494]	SETUPVAL 	R4 U12 ; U12 := R4
	134	[495]	OP_LOADBOOL	R4 0 0 ; R4 := false
	135	[495]	SETUPVAL 	R4 U13 ; U13 := R4
	136	[498]	GETGLOBAL	R4 K8 ; R4 := _T
	137	[498]	GETTABLE 	R4 R4 K13 ; R4 := R4["MultiTool"]
	138	[498]	GETUPVAL 	R5 U12 ; R5 := U12
	139	[498]	SETTABLE 	R4 K14 R5 ; R4["CurrentTargetRepairInfo"] := R5
	140	[499]	GETGLOBAL	R4 K8 ; R4 := _T
	141	[499]	GETTABLE 	R4 R4 K13 ; R4 := R4["MultiTool"]
	142	[499]	GETUPVAL 	R5 U14 ; R5 := U14
	143	[499]	CALL     	R5 1 2 ; R5 := R5()
	144	[499]	SETTABLE 	R4 K15 R5 ; R4["Revolite"] := R5
	145	[500]	GETGLOBAL	R4 K8 ; R4 := _T
	146	[500]	GETTABLE 	R4 R4 K13 ; R4 := R4["MultiTool"]
	147	[500]	GETUPVAL 	R5 U13 ; R5 := U13
	148	[500]	SETTABLE 	R4 K16 R5 ; R4["HasEnoughRevolite"] := R5
	149	[501]	RETURN   	R0 1 ; return 

function #22 <?:503,520> (59 instructions, 236 bytes at 0000016098C74A50)
1 param, 6 slots, 9 upvalues, 0 locals, 13 constants, 0 functions
	1	[504]	GETUPVAL 	R1 U0 ; R1 := U0
	2	[504]	LOADK    	R2 K0 ; R2 := "OnEquipped master? "
	3	[504]	GETGLOBAL	R3 K1 ; R3 := 0x64fb1586
	4	[504]	GETGLOBAL	R4 K2 ; R4 := 0x89326c93
	5	[504]	SELF     	R4 R4 K3 ; R5 := R4; R4 := R4[0x18d05d30]
	6	[504]	CALL     	R4 2 0 ; R4,... := R4(R5)
	7	[504]	CALL     	R3 0 2 ; R3 := R3(R4,...)
	8	[504]	CONCAT   	R2 R2 R3 ; R2 := R2 .. R3
	9	[504]	CALL     	R1 2 1 ; R1(R2)
	10	[505]	GETUPVAL 	R1 U1 ; R1 := U1
	11	[505]	CALL     	R1 1 1 ; R1()
	12	[507]	SETUPVAL 	R0 U2 ; U2 := R0
	13	[508]	GETUPVAL 	R1 U2 ; R1 := U2
	14	[508]	SELF     	R1 R1 K4 ; R2 := R1; R1 := R1[0x20833f15]
	15	[508]	CALL     	R1 2 2 ; R1 := R1(R2)
	16	[508]	SETUPVAL 	R1 U3 ; U3 := R1
	17	[510]	GETGLOBAL	R1 K5 ; R1 := 0x7b998233
	18	[510]	GETUPVAL 	R2 U3 ; R2 := U3
	19	[510]	CALL     	R1 2 2 ; R1 := R1(R2)
	20	[510]	TEST     	R1 1 ; if R1 then PC := 59
	21	[510]	JMP      	59 ; PC := 59
	22	[511]	GETUPVAL 	R1 U3 ; R1 := U3
	23	[511]	SELF     	R1 R1 K6 ; R2 := R1; R1 := R1[0xf7028472]
	24	[511]	GETUPVAL 	R3 U5 ; R3 := U5
	25	[511]	GETTABLE 	R3 R3 K7 ; R3 := R3["sSkillMultiToolExpert"]
	26	[511]	CALL     	R1 3 2 ; R1 := R1(R2,R3)
	27	[511]	SETUPVAL 	R1 U4 ; U4 := R1
	28	[512]	GETUPVAL 	R1 U3 ; R1 := U3
	29	[512]	SELF     	R1 R1 K8 ; R2 := R1; R1 := R1[0xde321e6f]
	30	[512]	CALL     	R1 2 2 ; R1 := R1(R2)
	31	[512]	SETUPVAL 	R1 U6 ; U6 := R1
	32	[513]	GETUPVAL 	R1 U2 ; R1 := U2
	33	[513]	SELF     	R1 R1 K9 ; R2 := R1; R1 := R1[0x870e163a]
	34	[513]	CALL     	R1 2 2 ; R1 := R1(R2)
	35	[513]	SELF     	R1 R1 K10 ; R2 := R1; R1 := R1[0xd60b781a]
	36	[513]	CALL     	R1 2 2 ; R1 := R1(R2)
	37	[513]	SETUPVAL 	R1 U7 ; U7 := R1
	38	[515]	GETGLOBAL	R1 K5 ; R1 := 0x7b998233
	39	[515]	GETUPVAL 	R2 U2 ; R2 := U2
	40	[515]	CALL     	R1 2 2 ; R1 := R1(R2)
	41	[515]	TEST     	R1 1 ; if R1 then PC := 59
	42	[515]	JMP      	59 ; PC := 59
	43	[515]	GETGLOBAL	R1 K5 ; R1 := 0x7b998233
	44	[515]	GETUPVAL 	R2 U3 ; R2 := U3
	45	[515]	CALL     	R1 2 2 ; R1 := R1(R2)
	46	[515]	TEST     	R1 1 ; if R1 then PC := 59
	47	[515]	JMP      	59 ; PC := 59
	48	[515]	GETUPVAL 	R1 U3 ; R1 := U3
	49	[515]	SELF     	R1 R1 K11 ; R2 := R1; R1 := R1[0x4accf179]
	50	[515]	CALL     	R1 2 2 ; R1 := R1(R2)
	51	[515]	TEST     	R1 0 ; if not R1 then PC := 59
	52	[515]	JMP      	59 ; PC := 59
	53	[516]	GETUPVAL 	R1 U8 ; R1 := U8
	54	[516]	CALL     	R1 1 1 ; R1()
	55	[517]	GETGLOBAL	R1 K12 ; R1 := 0xcbd666e1
	56	[517]	LOADK    	R2 := 0.000000
	57	[517]	CALL     	R1 2 1 ; R1(R2)
	58	[517]	JMP      	38 ; PC := 38
	59	[520]	RETURN   	R0 1 ; return 

function #23 <?:526,578> (138 instructions, 552 bytes at 0000016098C74AE0)
2 params, 14 slots, 1 upvalue, 0 locals, 28 constants, 0 functions
	1	[527]	GETGLOBAL	R2 K0 ; R2 := 0x89326c93
	2	[527]	SELF     	R2 R2 K1 ; R3 := R2; R2 := R2[0x18d05d30]
	3	[527]	CALL     	R2 2 2 ; R2 := R2(R3)
	4	[527]	TEST     	R2 0 ; if not R2 then PC := 138
	5	[527]	JMP      	138 ; PC := 138
	6	[528]	SELF     	R2 R0 K2 ; R3 := R0; R2 := R0[0x0454650e]
	7	[528]	CALL     	R2 2 2 ; R2 := R2(R3)
	8	[529]	GETGLOBAL	R3 K3 ; R3 := 0x7b998233
	9	[529]	GETGLOBAL	R4 K4 ; R4 := _T
	10	[529]	GETTABLE 	R4 R4 K5 ; R4 := R4["multiToolAmmoReduction"]
	11	[529]	CALL     	R3 2 2 ; R3 := R3(R4)
	12	[529]	TEST     	R3 1 ; if R3 then PC := 17
	13	[529]	JMP      	17 ; PC := 17
	14	[530]	GETGLOBAL	R3 K4 ; R3 := _T
	15	[530]	GETTABLE 	R3 R3 K5 ; R3 := R3["multiToolAmmoReduction"]
	16	[530]	MUL      	R2 R2 R3 ; R2 := R2 * R3
	17	[533]	GETGLOBAL	R3 K3 ; R3 := 0x7b998233
	18	[533]	MOVE     	R4 R1 ; R4 := R1
	19	[533]	CALL     	R3 2 2 ; R3 := R3(R4)
	20	[533]	TEST     	R3 1 ; if R3 then PC := 67
	21	[533]	JMP      	67 ; PC := 67
	22	[533]	GETGLOBAL	R3 K6 ; R3 := 0xb5a654de
	23	[533]	TEST     	R3 0 ; if not R3 then PC := 30
	24	[533]	JMP      	30 ; PC := 30
	25	[533]	SELF     	R3 R1 K7 ; R4 := R1; R3 := R1[0xf2deaf69]
	26	[533]	GETGLOBAL	R5 K8 ; R5 := gLotusNpcAvatarType
	27	[533]	CALL     	R3 3 2 ; R3 := R3(R4,R5)
	28	[533]	TEST     	R3 1 ; if R3 then PC := 67
	29	[533]	JMP      	67 ; PC := 67
	30	[534]	SELF     	R3 R1 K7 ; R4 := R1; R3 := R1[0xf2deaf69]
	31	[534]	GETGLOBAL	R5 K9 ; R5 := gLotusOperatorAvatarType
	32	[534]	CALL     	R3 3 2 ; R3 := R3(R4,R5)
	33	[534]	TEST     	R3 0 ; if not R3 then PC := 56
	34	[534]	JMP      	56 ; PC := 56
	35	[535]	SELF     	R3 R1 K10 ; R4 := R1; R3 := R1[0x5b89142c]
	36	[535]	CALL     	R3 2 2 ; R3 := R3(R4)
	37	[536]	GETGLOBAL	R4 K3 ; R4 := 0x7b998233
	38	[536]	MOVE     	R5 R3 ; R5 := R3
	39	[536]	CALL     	R4 2 2 ; R4 := R4(R5)
	40	[536]	TEST     	R4 1 ; if R4 then PC := 67
	41	[536]	JMP      	67 ; PC := 67
	42	[537]	SELF     	R4 R3 K11 ; R5 := R3; R4 := R3[0xa534c3ac]
	43	[537]	CALL     	R4 2 2 ; R4 := R4(R5)
	44	[538]	GETGLOBAL	R5 K3 ; R5 := 0x7b998233
	45	[538]	MOVE     	R6 R4 ; R6 := R4
	46	[538]	CALL     	R5 2 2 ; R5 := R5(R6)
	47	[538]	TEST     	R5 1 ; if R5 then PC := 67
	48	[538]	JMP      	67 ; PC := 67
	49	[539]	SELF     	R5 R4 K12 ; R6 := R4; R5 := R4[0xde321e6f]
	50	[539]	CALL     	R5 2 2 ; R5 := R5(R6)
	51	[539]	SELF     	R5 R5 K13 ; R6 := R5; R5 := R5[0x936fc1c2]
	52	[539]	GETGLOBAL	R7 K14 ; R7 := 0x186b715b
	53	[539]	MOVE     	R8 R2 ; R8 := R2
	54	[539]	CALL     	R5 4 1 ; R5(R6,R7,R8)
	55	[541]	JMP      	67 ; PC := 67
	56	[543]	SELF     	R5 R1 K12 ; R6 := R1; R5 := R1[0xde321e6f]
	57	[543]	CALL     	R5 2 2 ; R5 := R5(R6)
	58	[544]	GETGLOBAL	R6 K3 ; R6 := 0x7b998233
	59	[544]	MOVE     	R7 R5 ; R7 := R5
	60	[544]	CALL     	R6 2 2 ; R6 := R6(R7)
	61	[544]	TEST     	R6 1 ; if R6 then PC := 67
	62	[544]	JMP      	67 ; PC := 67
	63	[545]	SELF     	R6 R5 K13 ; R7 := R5; R6 := R5[0x936fc1c2]
	64	[545]	GETGLOBAL	R8 K14 ; R8 := 0x186b715b
	65	[545]	MOVE     	R9 R2 ; R9 := R2
	66	[545]	CALL     	R6 4 1 ; R6(R7,R8,R9)
	67	[550]	GETGLOBAL	R6 K3 ; R6 := 0x7b998233
	68	[550]	MOVE     	R7 R1 ; R7 := R1
	69	[550]	CALL     	R6 2 2 ; R6 := R6(R7)
	70	[550]	TEST     	R6 1 ; if R6 then PC := 138
	71	[550]	JMP      	138 ; PC := 138
	72	[551]	SELF     	R6 R1 K12 ; R7 := R1; R6 := R1[0xde321e6f]
	73	[551]	CALL     	R6 2 2 ; R6 := R6(R7)
	74	[552]	GETGLOBAL	R7 K3 ; R7 := 0x7b998233
	75	[552]	MOVE     	R8 R6 ; R8 := R6
	76	[552]	CALL     	R7 2 2 ; R7 := R7(R8)
	77	[552]	TEST     	R7 1 ; if R7 then PC := 118
	78	[552]	JMP      	118 ; PC := 118
	79	[553]	SELF     	R7 R0 K15 ; R8 := R0; R7 := R0[0xea969abd]
	80	[553]	CALL     	R7 2 2 ; R7 := R7(R8)
	81	[555]	GETGLOBAL	R8 K4 ; R8 := _T
	82	[555]	GETTABLE 	R8 R8 K16 ; R8 := R8["NpcRepairXPRewarded"]
	83	[555]	EQ       	0 R8 K17 ; if R8 ~= nil then PC := 87
	84	[555]	JMP      	87 ; PC := 87
	85	[556]	GETGLOBAL	R8 K4 ; R8 := _T
	86	[556]	SETTABLE 	R8 K16 K18 ; R8["NpcRepairXPRewarded"] := 0.000000
	87	[559]	SELF     	R8 R1 K19 ; R9 := R1; R8 := R1[0x35844cf2]
	88	[559]	CALL     	R8 2 2 ; R8 := R8(R9)
	89	[559]	TEST     	R8 1 ; if R8 then PC := 96
	90	[559]	JMP      	96 ; PC := 96
	91	[559]	GETGLOBAL	R8 K4 ; R8 := _T
	92	[559]	GETTABLE 	R8 R8 K16 ; R8 := R8["NpcRepairXPRewarded"]
	93	[559]	GETGLOBAL	R9 K20 ; R9 := 0x5fa5788e
	94	[559]	LT       	0 R8 R9 ; if R8 >= R9 then PC := 118
	95	[559]	JMP      	118 ; PC := 118
	96	[560]	SELF     	R8 R1 K19 ; R9 := R1; R8 := R1[0x35844cf2]
	97	[560]	CALL     	R8 2 2 ; R8 := R8(R9)
	98	[560]	TEST     	R8 1 ; if R8 then PC := 105
	99	[560]	JMP      	105 ; PC := 105
	100	[562]	GETGLOBAL	R8 K4 ; R8 := _T
	101	[562]	GETGLOBAL	R9 K4 ; R9 := _T
	102	[562]	GETTABLE 	R9 R9 K16 ; R9 := R9["NpcRepairXPRewarded"]
	103	[562]	ADD      	R9 R9 K21 ; R9 := R9 + 1.000000
	104	[562]	SETTABLE 	R8 K16 R9 ; R8["NpcRepairXPRewarded"] := R9
	105	[564]	SELF     	R8 R6 K22 ; R9 := R6; R8 := R6[0x8db2624f]
	106	[564]	MOVE     	R10 R7 ; R10 := R7
	107	[564]	MOVE     	R11 R1 ; R11 := R1
	108	[564]	GETUPVAL 	R12 U0 ; R12 := U0
	109	[564]	OP_LOADBOOL	R13 0 0 ; R13 := false
	110	[564]	CALL     	R8 6 1 ; R8(R9,R10,R11,R12,R13)
	111	[565]	SELF     	R8 R6 K23 ; R9 := R6; R8 := R6[0x2bfc9e36]
	112	[565]	MOVE     	R10 R7 ; R10 := R7
	113	[565]	MOVE     	R11 R1 ; R11 := R1
	114	[565]	SELF     	R12 R1 K24 ; R13 := R1; R12 := R1[0xcde10c4a]
	115	[565]	CALL     	R12 2 2 ; R12 := R12(R13)
	116	[565]	GETUPVAL 	R13 U0 ; R13 := U0
	117	[565]	CALL     	R8 6 1 ; R8(R9,R10,R11,R12,R13)
	118	[569]	SELF     	R8 R1 K25 ; R9 := R1; R8 := R1[0x5e651723]
	119	[569]	CALL     	R8 2 2 ; R8 := R8(R9)
	120	[570]	GETGLOBAL	R9 K3 ; R9 := 0x7b998233
	121	[570]	MOVE     	R10 R8 ; R10 := R8
	122	[570]	CALL     	R9 2 2 ; R9 := R9(R10)
	123	[570]	TEST     	R9 1 ; if R9 then PC := 138
	124	[570]	JMP      	138 ; PC := 138
	125	[570]	SELF     	R9 R1 K19 ; R10 := R1; R9 := R1[0x35844cf2]
	126	[570]	CALL     	R9 2 2 ; R9 := R9(R10)
	127	[570]	TEST     	R9 0 ; if not R9 then PC := 138
	128	[570]	JMP      	138 ; PC := 138
	129	[571]	SELF     	R9 R8 K26 ; R10 := R8; R9 := R8[0x61c34fa9]
	130	[571]	CALL     	R9 2 2 ; R9 := R9(R10)
	131	[572]	GETGLOBAL	R10 K3 ; R10 := 0x7b998233
	132	[572]	MOVE     	R11 R9 ; R11 := R9
	133	[572]	CALL     	R10 2 2 ; R10 := R10(R11)
	134	[572]	TEST     	R10 1 ; if R10 then PC := 138
	135	[572]	JMP      	138 ; PC := 138
	136	[573]	SELF     	R10 R9 K27 ; R11 := R9; R10 := R9[0xd1372c89]
	137	[573]	CALL     	R10 2 1 ; R10(R11)
	138	[578]	RETURN   	R0 1 ; return 

function #24 <?:580,581> (1 instruction, 4 bytes at 0000016098C74B70)
2 params, 2 slots, 0 upvalues, 0 locals, 0 constants, 0 functions
	1	[581]	RETURN   	R0 1 ; return 
